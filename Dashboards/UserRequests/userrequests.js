// Generated by Copilot
// =================================================================
//                      STATE & CONFIGURATION
// =================================================================
const TABLE_CONTAINER_ID = 'requests-table-area';
const API_GET_REQUESTS = 'GetRequests';
const API_DELETE_REQUEST = 'DeleteRequestID';
const API_GET_REQUEST_DETAILS = 'GetRequestID';
const API_GET_DATASET_DETAILS = 'GetDataSetID';
const API_GET_ASSIST_PROJECTS = 'GetAssistProjectsFilteredByUpn';

// We will store all fetched data here
let allRequests = []; 
let currentPage = 1;
const rowsPerPage = 5; // You can control page size here

// Helper function to get search input lazily (for test compatibility)
function getSearchInput() {
    return document.getElementById('searchRequests');
}

// Mapping from Status ID to Status Name
const statusIdToNameMap = { 1: 'Pending Approval', 2: 'Approved', 3: 'Finalised', 4: 'Rejected' };

// Configuration for each status tab
const configMap = {
    'Pending Approval': { showActions: true },
    'Approved': { showActions: true },
    'Rejected': { showActions: true },
    'Finalised': { showActions: true },
};

// =================================================================
//                      UTILITY & MODAL FUNCTIONS
// =================================================================
function ViewRequest(request) {
    // Get the modal's body element
    const modalBody = document.getElementById('viewRequestModalBody');
    console.log("IN VIEW REQ")
    // Populate the modal body with the provided HTML content (your markup)
    modalBody.innerHTML = `
        <form>
            <div class="form-group">
            <label for="Name" class="control-label">Request Name</label>
            <input id="Name" class="form-control" disabled="true" value="${request.name}">
        </div>
            <div class="form-group">
                <label for="ProjectID" class="control-label">Assist Project</label>
                <select id="ProjectID" disabled="true" class="form-control selectpicker valid">
                    <option value="-1">Assist Project 1</option>
                </select>
            </div>
            <div class="form-group">
                <label for="ScheduleRefresh" class="control-label">Scheduled Refresh</label>
                <select id="ScheduleRefresh" disabled="true" class="form-control selectpicker valid">
                    <option value="No Refresh">No Refresh</option>
                    <option value="Daily">Daily</option>
                    <option value="Weekly">Weekly</option>
                    <option value="Monthly">Monthly</option>
                </select>
            </div>
            <div class="row">
                <label for="ScheduleRefresh" class="control-label">Filter's for this Data Set</label>
                <div class="table-responsive">
                    <table class="table table-condensed table-striped">
                        <thead>
                            <tr>
                                <th>Column</th>
                                <th>Filter Type</th>
                                <th>Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Example of empty table body; data can be populated later -->
                            <tr>
                                <td colspan="3">No filters available.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </form>
    `;

}

async function ViewDataSet(request) {
    return new Promise(async (resolve, reject) => {
        try {
            // You can still update the modal if needed
            const modalBody = document.getElementById('viewDatasetModalBody');
            
            // Fetch dataset details - replace this with your actual data fetching logic
            // This could be an API call, database query, etc.
            const datasetDetails = await fetchDatasetDetails(request.DataSetID);
            
            // If you still want to update the modal
            if (modalBody) {
                // Format the dataset details for the modal
                let modalContent = `
                    <div class="form-group">
                        <label for="DataSetType" class="form-check-label">Data Source</label>
                        <select disabled="true" class="form-control selectpicker valid">
                            <option value="1" ${datasetDetails.DataSourceID === 1 ? 'selected' : ''}>BIS Data (pilot test)</option>
                            <option value="4" ${datasetDetails.DataSourceID === 4 ? 'selected' : ''}>Barwon Health DB Source View 1</option>
                            <option value="25" ${datasetDetails.DataSourceID === 25 ? 'selected' : ''}>Source Mock SQL Data for Testing</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <div class="form-check">
                            <input id="Active" disabled="true" type="checkbox" class="form-check-input valid" ${datasetDetails.Active ? 'checked' : ''}>
                            <label for="Active" class="form-check-label">Active</label>
                        </div>
                    </div>
                    <br>
                    <h6>Data Set Fields</h6>
                    <div class="table-responsive">
                        <table class="table table-condensed table-striped">
                            <thead>
                                <tr>
                                    <th>Field Name</th>
                                    <th>Type</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                // Add dataset fields to the modal
                if (datasetDetails.Fields && datasetDetails.Fields.length > 0) {
                    datasetDetails.Fields.forEach(field => {
                        modalContent += `
                            <tr>
                                <td>${field.Name}</td>
                                <td>${field.Type}</td>
                                <td>${field.Description || ''}</td>
                            </tr>
                        `;
                    });
                } else {
                    modalContent += `<tr><td colspan="3" class="text-center">No fields available</td></tr>`;
                }
                
                modalContent += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                modalBody.innerHTML = modalContent;
            }
            
            // Format the dataset details for the accordion
            const formattedDetails = {
                DataSetID: datasetDetails.DataSetID,
                Name: datasetDetails.Name,
                Description: datasetDetails.Description || 'No description available',
                DataSource: getDataSourceName(datasetDetails.DataSourceID),
                Active: datasetDetails.Active ? 'Yes' : 'No',
                CreatedDate: formatDate(datasetDetails.CreatedDate),
                LastModified: formatDate(datasetDetails.LastModified),
                FieldCount: datasetDetails.Fields ? datasetDetails.Fields.length : 0,
                Fields: formatFieldsForAccordion(datasetDetails.Fields)
            };
            
            // Resolve the promise with the formatted details
            resolve(formattedDetails);
            
        } catch (error) {
            console.error('Error fetching dataset details:', error);
            reject(error);
        }
    });
}

// Helper function to get data source name from ID
function getDataSourceName(dataSourceID) {
    const dataSources = {
        1: 'BIS Data (pilot test)',
        4: 'Barwon Health DB Source View 1',
        25: 'Source Mock SQL Data for Testing'
    };
    return dataSources[dataSourceID] || `Unknown Source (${dataSourceID})`;
}

// Helper function to format fields for the accordion
function formatFieldsForAccordion(fields) {
    if (!fields || fields.length === 0) {
        return 'No fields available';
    }
    
    let fieldsHtml = '<div class="mt-2"><table class="w-full text-sm"><thead><tr><th class="text-left">Field</th><th class="text-left">Type</th></tr></thead><tbody>';
    
    fields.forEach(field => {
        fieldsHtml += `<tr><td>${field.Name}</td><td>${field.Type}</td></tr>`;
    });
    
    fieldsHtml += '</tbody></table></div>';
    return fieldsHtml;
}


// =================================================================
// Miguel
function DeleteRequest(request) {
    // Get the modal elements
    const modalBody = document.getElementById('deleteRequestModalBody');
    const modalTitle = document.getElementById('deleteRequestModalLabel');
    
    // Update the modal title
    modalTitle.textContent = `Delete Request`;
    
    // Populate the modal body with the confirmation message
    modalBody.innerHTML = `
        <div class="col-md-12">
            <div class="alert alert-warning">
                <i class="fa fa-exclamation-triangle"></i> 
                You are about to delete the request:<br>
                <strong>${request.Name}</strong>
            </div>
            <div class="form-group mt-3 d-flex justify-content-center">
                <button id="confirmDeleteBtn" class="btn btn-danger px-3 py-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                    Delete
                </button>
            </div>
        </div>
    `;
    
    // Add event listener for the confirm delete button
    setTimeout(() => {
        const confirmBtn = document.getElementById('confirmDeleteBtn');
        if (confirmBtn) {
            console.log('Adding click listener to confirm delete button');
            confirmBtn.addEventListener('click', () => {
                console.log('Delete button clicked for request:', request.RequestID);
                // Call the API to delete the request
                deleteRequestFromAPI(request.RequestID);
            });
        } else {
            console.error('Confirm delete button not found');
        }
    }, 100);
}

async function deleteRequestFromAPI(requestId) {
    let loadingToast = null;
    
    try {
        console.log('Starting delete request process for ID:', requestId);
        
        // Show loading state
        loadingToast = showToast('Deleting request...', 'info');
        console.log('Loading toast shown:', loadingToast);
        
        const response = await window.loomeApi.runApiRequest(API_DELETE_REQUEST, {
            "id": requestId,
        });
        
        // Log the response to console
        console.log('Delete request API response:', response);
        
        // Hide the modal
        try {
            const deleteModal = bootstrap.Modal.getInstance(document.getElementById('deleteRequestModal'));
            if (deleteModal) {
                deleteModal.hide();
                console.log('Delete modal hidden');
            } else {
                console.log('Delete modal not found or already hidden');
            }
        } catch (modalError) {
            console.error('Error hiding modal:', modalError);
        }
        
        // Hide loading toast
        if (loadingToast) {
            hideToast(loadingToast);
            console.log('Loading toast hidden');
        }
        
        // Show success message
        const successToast = showToast('Request deleted successfully', 'success');
        console.log('Success toast shown:', successToast);
        
        // Update all chip counts after deletion
        console.log('Refreshing chip counts');
        await refreshAllChipCounts();

        // Refresh the UI
        console.log('Refreshing UI');
        setTimeout(() => {
            renderUI();
        }, 100);
        
    } catch (error) {
        console.error("Error deleting request:", error);
        
        // Hide loading toast
        if (loadingToast) {
            hideToast(loadingToast);
            console.log('Loading toast hidden after error');
        }
        
        // Show error message
        const errorToast = showToast('Failed to delete request. Please try again.', 'error');
        console.log('Error toast shown:', errorToast);
    }
}

// Toast notification functions
function showToast(message, type = 'info') {
    console.log(`Showing toast: ${message} (${type})`);
    
    const toastContainer = document.getElementById('toast-container') || createToastContainer();
    const toast = document.createElement('div');
    
    // Add styling based on type
    let backgroundColor, textColor;
    switch(type) {
        case 'success':
            backgroundColor = '#4caf50';
            textColor = 'white';
            break;
        case 'error':
            backgroundColor = '#f44336';
            textColor = 'white';
            break;
        case 'info':
        default:
            backgroundColor = '#2196F3';
            textColor = 'white';
    }
    
    // Apply styles directly
    toast.style.cssText = `
        margin-bottom: 10px;
        padding: 15px 20px;
        border-radius: 4px;
        color: ${textColor};
        background-color: ${backgroundColor};
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        display: flex;
        align-items: center;
        min-width: 250px;
        max-width: 350px;
        opacity: 0;
        transition: opacity 0.3s ease;
    `;
    
    toast.innerHTML = `
        <div style="flex-grow: 1;">${message}</div>
    `;
    
    toastContainer.appendChild(toast);
    
    // Trigger reflow to ensure transition works
    void toast.offsetWidth;
    
    // Make visible
    toast.style.opacity = '1';
    
    // Auto-hide after 3 seconds for success messages
    if (type === 'success') {
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 500); //Fade out transition for 500 milliseconds
        }, 5000); // Display duration of 5 seconds
    }
    
    console.log('Toast created and appended to container');
    return toast;
}

function hideToast(toast) {
    if (toast && toast.parentNode) {
        console.log('Hiding toast');
        toast.style.opacity = '0';
        setTimeout(() => {
            if (toast && toast.parentNode) {
                toast.remove();
                console.log('Toast removed');
            }
        }, 300); // Wait for fade out
    } else {
        console.log('Toast not found or already removed');
    }
}

function createToastContainer() {
    const container = document.createElement('div');
    container.id = 'toast-container';
    container.className = 'toast-top-right';
    container.style.cssText = 'position: fixed; top: 12px; right: 12px; z-index: 9999;';
    document.body.appendChild(container);
    return container;
}


/**
 * Fetches request details from the API
 * @param {string|number} requestID - The ID of the request
 * @returns {Promise<object>} - The request details
 */
async function fetchRequestDetails(requestID) {
    try {
        // Call the API
        const response = await window.loomeApi.runApiRequest(API_GET_REQUEST_DETAILS, {
            "RequestID": requestID,
        });
        
        // Parse the response
        return safeParseJson(response);
    } catch (error) {
        console.error(`Error fetching request details for ID ${requestID}:`, error);
        throw error;
    }
}

/**
 * Fetches dataset details from the API
 * @param {string|number} datasetID - The ID of the dataset
 * @returns {Promise<object>} - The dataset details
 */
async function fetchDatasetDetails(datasetID) {
    try {
        // Call the API
        const response = await window.loomeApi.runApiRequest(API_GET_DATASET_DETAILS, {
            "DataSetID": datasetID,
        });
        
        // Parse the response
        return safeParseJson(response);
    } catch (error) {
        console.error(`Error fetching dataset details for ID ${datasetID}:`, error);
        throw error;
    }
}



// Global variable to store project data
let projectsCache = null;

/**
 * Fetches all projects and caches them
 * @returns {Promise<Object>} A mapping from project ID to project name
 */
async function getProjectsMapping() {
    // Return cache if already loaded
    if (projectsCache) {
        return projectsCache;
    }
    
    try {
        
        // Fetch projects data
        const response = await window.loomeApi.runApiRequest(API_GET_ASSIST_PROJECTS);
        const data = safeParseJson(response);
        
        // Create a mapping from project ID to project name
        const mapping = {};
        if (data && data.Results && Array.isArray(data.Results)) {
            data.Results.forEach(project => {
                mapping[project.AssistProjectID] = {
                    name: project.Name,
                    description: project.Description
                };
            });
        }
        
        // Cache the mapping
        projectsCache = mapping;
        return mapping;
        
    } catch (error) {
        console.error("Error fetching projects:", error);
        return {}; // Return empty object in case of error
    }
}


/**
 * Displays request details in the container
 * @param {HTMLElement} container - The container element
 * @param {object} details - The request details
 */
async function displayRequestDetails(container, details) {
    // Check if we have valid details
    if (!details || Object.keys(details).length === 0) {
        container.innerHTML = '<p class="text-center text-red-500">No request details available</p>';
        return;
    }
    
    // Show loading state
    container.innerHTML = '<p class="text-center">Loading project details...</p>';
    
    try {
        // Get project mapping
        const projectsMapping = await getProjectsMapping();
        const projectInfo = projectsMapping[details.ProjectID] || { name: 'Unknown Project', description: '' };
        
        // Format the details for display
        let html = '';
        
        // Add basic request information
        html += `
            <p><strong>Target Project Name:</strong> ${projectInfo.name}</p>
        `;
        
        // Add project description if available
        if (projectInfo.description) {
            html += `<p><strong>Project Description:</strong> ${projectInfo.description}</p>`;
        }
        
        // // Add status-specific fields
        // if (details.Approvers) html += `<p><strong>Approvers:</strong> ${details.Approvers}</p>`;
        // if (details.ApprovedBy) html += `<p><strong>Approved By:</strong> ${details.ApprovedBy}</p>`;
        // if (details.ApprovedDate) html += `<p><strong>Approved Date:</strong> ${formatDate(details.ApprovedDate)}</p>`;
        // if (details.RejectedBy) html += `<p><strong>Rejected By:</strong> ${details.RejectedBy}</p>`;
        // if (details.RejectedDate) html += `<p><strong>Rejected Date:</strong> ${formatDate(details.RejectedDate)}</p>`;
        // if (details.FinalisedDate) html += `<p><strong>Finalised Date:</strong> ${formatDate(details.FinalisedDate)}</p>`;
        
        // // Add any additional fields from the API response
        // const standardFields = ['RequestID', 'ProjectID', 'Name', 'Description', 'CreateDate', 'Status', 
        //                       'Approvers', 'ApprovedBy', 'ApprovedDate', 'RejectedBy', 
        //                       'RejectedDate', 'FinalisedDate'];
        
        // for (const [key, value] of Object.entries(details)) {
        //     if (!standardFields.includes(key) && value !== null && value !== undefined) {
        //         html += `<p><strong>${key}:</strong> ${value}</p>`;
        //     }
        // }
        
        // Update the container
        container.innerHTML = html;
        
    } catch (error) {
        console.error("Error displaying request details:", error);
        container.innerHTML = `
            <p class="text-center text-red-500">Error loading project details</p>
            <div class="mt-3">
                <p><strong>Request ID:</strong> ${details.RequestID || 'N/A'}</p>
                <p><strong>Name:</strong> ${details.Name || 'N/A'}</p>
                <p><strong>Project ID:</strong> ${details.ProjectID || 'N/A'}</p>
                <p><strong>Status:</strong> ${details.Status || 'Unknown'}</p>
                <!-- Add other critical fields here -->
            </div>
        `;
    }
}

/**
 * Displays dataset details in the container
 * @param {HTMLElement} container - The container element
 * @param {object} details - The dataset details
 */
function displayDatasetDetails(container, details) {
    // Check if we have valid details
    if (!details || Object.keys(details).length === 0) {
        container.innerHTML = '<p class="text-center text-red-500">No dataset details available</p>';
        return;
    }
    
    // Format the details for display
    let html = '';
    
    // Add basic dataset information
    html += `
        <p><strong>Requested Dataset:</strong> ${details.Name || 'N/A'}</p>
        <p><strong>Description:</strong> ${details.Description || 'N/A'}</p>
        <p><strong>Data Source ID:</strong> ${details.DataSourceID || 'N/A'}</p>
    `;
    
    // Add fields table if available
    if (details.Fields && details.Fields.length > 0) {
        html += `
            <div class="mt-3">
                <strong>Fields:</strong>
                <div class="mt-2">
                    <table class="w-full text-sm">
                        <thead>
                            <tr>
                                <th class="text-left">Field</th>
                                <th class="text-left">Type</th>
                                <th class="text-left">Description</th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        
        details.Fields.forEach(field => {
            html += `
                <tr>
                    <td>${field.Name || 'N/A'}</td>
                    <td>${field.Type || 'N/A'}</td>
                    <td>${field.Description || ''}</td>
                </tr>
            `;
        });
        
        html += `
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    }
    
    // Update the container
    container.innerHTML = html;
}
// =================================================================


/**
 * Displays combined request and dataset details in a single container
 * @param {HTMLElement} container - The container element
 * @param {object} requestDetails - The request details
 * @param {object} datasetDetails - The dataset details
 */
async function displayCombinedDetails(container, requestDetails, datasetDetails) {
    // Check if we have valid details
    if ((!requestDetails || Object.keys(requestDetails).length === 0) && 
        (!datasetDetails || Object.keys(datasetDetails).length === 0)) {
        container.innerHTML = '<p class="text-center text-red-500">No details available</p>';
        return;
    }
    
    // Show loading state
    container.innerHTML = '<p class="text-center">Loading details...</p>';
    
    try {
        // Get project mapping for request details
        const projectsMapping = await getProjectsMapping();
        const projectInfo = requestDetails && requestDetails.ProjectID ? 
            (projectsMapping[requestDetails.ProjectID] || { name: 'Unknown Project', description: '' }) : 
            { name: 'Unknown Project', description: '' };
        
        // Start building HTML
        let html = `
            <div class="grid grid-cols-1 gap-5">
                <!-- Request Information -->
                <div>
                    <div class="space-y-3">
                       
                        <!-- Dataset Information -->
                        <div class="grid grid-cols-1 gap-1">
                            <span class="font-medium">Requested Dataset</span>
                            <span class="text-sm text-gray-500">${datasetDetails.Name || 'N/A'}</span>
                        </div>

                        ${datasetDetails.Description ? `
                        <div class="grid grid-cols-1 gap-1">
                            <span class="font-medium">Dataset Description</span>
                            <span class="text-sm text-gray-500">${datasetDetails.Description}</span>
                        </div>` : ''}
                        
                        <div class="grid grid-cols-1 gap-1">
                            <span class="font-medium">Data Source ID</span>
                            <span class="text-sm text-gray-500">${datasetDetails.DataSource || datasetDetails.DataSourceID || 'N/A'}</span>
                        </div>

                        <!-- Project Information -->
                        <div class="grid grid-cols-1 gap-1">
                            <span class="font-medium">Target Project Name</span>
                            <span class="text-sm text-gray-500">${projectInfo.name}</span>
                        </div>
                        
                        ${projectInfo.description ? `
                        <div class="grid grid-cols-1 gap-1">
                            <span class="font-medium">Project Description</span>
                            <span class="text-sm text-gray-500">${projectInfo.description}</span>
                        </div>` : ''}

                    </div>
                </div>
            </div>
        `;
        
        // Update the container
        container.innerHTML = html;
        
    } catch (error) {
        console.error("Error displaying combined details:", error);
        container.innerHTML = `
            <div class="p-3 bg-red-50 border border-red-200 rounded-md">
                <p class="text-center text-red-500 mb-2">Error loading details</p>
                <p class="text-sm">${error.message || 'Unknown error'}</p>
            </div>
        `;
    }
}


/**
 * Safely parses a response that might be a JSON string or an object.
 * @param {string | object} response The API response.
 * @returns {object}
 */
function safeParseJson(response) {
    return typeof response === 'string' ? JSON.parse(response) : response;
}

/**
* Renders a compact and functional set of pagination controls.
* Includes First, Previous, Next, Last buttons and a page input field.
*/
function renderPagination(containerId, totalItems, itemsPerPage, currentPage) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Pagination container with ID "${containerId}" not found.`);
        return;
    }

    const totalPages = Math.ceil(totalItems / itemsPerPage);
    container.innerHTML = ''; // Clear old controls

    if (totalPages <= 1) {
        return; // No need for pagination.
    }

    // --- Determine button states ---
    const isFirstPage = currentPage === 1;
    const isLastPage = currentPage === totalPages;
    const commonButtonClasses = "px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100";
    const disabledClasses = "opacity-50 cursor-not-allowed";

    // --- Build the HTML string ---
    let paginationHTML = `
        <div class="flex items-center gap-2">
            <!-- First Page Button -->
            <button data-page="1" 
                    class="${commonButtonClasses} ${isFirstPage ? disabledClasses : ''}" 
                    ${isFirstPage ? 'disabled' : ''}>
                First
            </button>
            <!-- Previous Page Button -->
            <button data-page="${currentPage - 1}" 
                    class="${commonButtonClasses} ${isFirstPage ? disabledClasses : ''}" 
                    ${isFirstPage ? 'disabled' : ''}>
                Previous
            </button>
        </div>

        <!-- Page number input and display -->
        <div class="flex items-center gap-2 text-sm text-gray-700">
            <span>Page</span>
            <input type="number" 
                   id="page-input" 
                   class="w-16 text-center border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50" 
                   value="${currentPage}" 
                   min="1" 
                   max="${totalPages}" 
                   aria-label="Current page">
            <span>of ${totalPages}</span>
        </div>

        <div class="flex items-center gap-2">
            <!-- Next Page Button -->
            <button data-page="${currentPage + 1}" 
                    class="${commonButtonClasses} ${isLastPage ? disabledClasses : ''}" 
                    ${isLastPage ? 'disabled' : ''}>
                Next
            </button>
            <!-- Last Page Button -->
            <button data-page="${totalPages}" 
                    class="${commonButtonClasses} ${isLastPage ? disabledClasses : ''}" 
                    ${isLastPage ? 'disabled' : ''}>
                Last
            </button>
        </div>
    `;

    container.innerHTML = paginationHTML;
}

function formatDate(inputDate) {
    // Log what the function receives
    console.log(`formatDate received:`, inputDate, `(type: ${typeof inputDate})`);

    if (!inputDate) {
        // This will be triggered if inputDate is null, undefined, or an empty string ""
        return 'N/A'; 
    }

    const date = new Date(inputDate);
    
    if (isNaN(date.getTime())) {
        // This will be triggered if the date string is invalid, e.g., "hello world"
        console.warn(`Could not parse invalid date:`, inputDate);
        return 'N/A';
    }
    
    const formattingOptions = {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    };
    
    // The only way this returns undefined is if the function exits before this line.
    return date.toLocaleDateString('en-US', formattingOptions);
}


// =================================================================
//                      API & RENDERING FUNCTIONS
// =================================================================


/**
 * Renders a data table with dynamic headers and actions.
 */
function renderTable(containerId, data, config, selectedStatus) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'w-full divide-y divide-gray-200';
    const thead = document.createElement('thead');
    thead.className = 'bg-gray-50';
    const headerRow = document.createElement('tr');
    
    // Add a column for the chevron
    const chevronTh = document.createElement('th');
    chevronTh.className = 'w-10 px-6 py-3';
    chevronTh.innerHTML = ''; // Empty header for chevron column
    headerRow.appendChild(chevronTh);
    
    // Define headers based on the selected status
    const headers = ['Request ID', 'Request Name', 'Requested On'];
    if (selectedStatus === 'Pending Approval') headers.push('Approvers');
    else if (selectedStatus === 'Approved') { headers.push('Approved by'); headers.push('Approved on'); }
    else if (selectedStatus === 'Rejected') { headers.push('Rejected by'); headers.push('Rejected on'); }
    else if (selectedStatus === 'Finalised') { headers.push('Approved by'); headers.push('Approved on'); headers.push('Finalised on'); }
            
    
    headers.forEach(headerText => {
        const th = document.createElement('th');
        th.className = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider';
        th.textContent = headerText;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    const tbody = document.createElement('tbody');
    tbody.className = 'bg-white divide-y divide-gray-200';
    
    if (data.length === 0) {
        const colSpan = headers.length + 1; // +1 for chevron column
        tbody.innerHTML = `<tr><td colspan="${colSpan}" class="px-6 py-4 text-center text-sm text-gray-500">No requests found.</td></tr>`;
    } else {
        data.forEach(item => {
            const row = document.createElement('tr');
            row.className = 'cursor-pointer hover:bg-gray-100';
            const tdClasses = 'px-6 py-4 whitespace-nowrap text-sm text-gray-800';
            
            let statusSpecificCols = '';
            switch (item.status) {
                case 'Pending Approval': statusSpecificCols = `<td class="${tdClasses}">${item.Approvers || 'N/A'}</td>`; break;
                case 'Rejected': statusSpecificCols = `<td class="${tdClasses}">${item.RejectedBy || 'N/A'}</td><td class="${tdClasses}">${formatDate(item.RejectedDate)}</td>`; break;
                case 'Approved': statusSpecificCols = `<td class="${tdClasses}">${item.CurrentlyApproved || 'N/A'}</td><td class="${tdClasses}">${formatDate(item.ApprovedDate)}</td>`; break;
                case 'Finalised': statusSpecificCols = `<td class="${tdClasses}">${item.CurrentlyApproved || 'N/A'}</td><td class="${tdClasses}">${formatDate(item.ApprovedDate)}</td><td class="${tdClasses}">${formatDate(item.FinalisedDate)}</td>`; break;
            }

            // Add chevron as first column
            row.innerHTML = `
                <td class="${tdClasses} text-center">
                    <svg class="chevron-icon h-5 w-5 text-gray-500 transform transition-transform duration-200 inline-block" 
                         xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </td>
                <td class="${tdClasses}">${item.RequestID}</td>
                <td class="${tdClasses}">${item.Name}</td>
                <td class="${tdClasses}">${formatDate(item.CreateDate)}</td>
                ${statusSpecificCols}
            `;
            
            // Add click event to toggle accordion
            row.addEventListener('click', async () => {
                // Toggle the accordion visibility
                accordionRow.classList.toggle('hidden');
                
                // Toggle chevron rotation
                const chevron = row.querySelector('.chevron-icon');
                chevron.classList.toggle('rotate-180');
                
                // Only fetch data if the accordion is becoming visible
                if (!accordionRow.classList.contains('hidden')) {
                    const combinedDetailsContainer = accordionRow.querySelector(`#combined-details-${item.RequestID}`);
                    
                    // Show loading indicator
                    combinedDetailsContainer.innerHTML = '<p class="text-center">Loading details...</p>';
                    
                    try {
                        console.log(`Fetching details for RequestID: ${item.RequestID}, DataSetID: ${item.DataSetID}`);
                        
                        // Try fetching request details first
                        let requestDetails;
                        try {
                            console.log('Fetching request details...');
                            requestDetails = await fetchRequestDetails(item.RequestID);
                            console.log('Request details received:', requestDetails);
                        } catch (requestError) {
                            console.error('Error fetching request details:', requestError);
                            requestDetails = null;
                        }
                        
                        // Then try fetching dataset details
                        let datasetDetails;
                        try {
                            console.log('Fetching dataset details...');
                            datasetDetails = await fetchDatasetDetails(item.DataSetID);
                            console.log('Dataset details received:', datasetDetails);
                        } catch (datasetError) {
                            console.error('Error fetching dataset details:', datasetError);
                            datasetDetails = null;
                        }
                        
                        // Check if we have at least one set of details
                        if (!requestDetails && !datasetDetails) {
                            throw new Error('Failed to fetch both request and dataset details');
                        }
                        
                        // Display whatever details we have
                        console.log('Displaying combined details');
                        displayCombinedDetails(combinedDetailsContainer, requestDetails, datasetDetails);
                        
                    } catch (error) {
                        console.error("Error loading details:", error);
                        combinedDetailsContainer.innerHTML = `
                            <div class="p-3 bg-red-50 border border-red-200 rounded-md">
                                <p class="text-center text-red-500 mb-2">Error loading details</p>
                                <p class="text-sm">${error.message || 'Unknown error'}</p>
                                <button class="mt-2 px-3 py-1 bg-white border border-gray-300 rounded text-sm retry-btn">
                                    Retry
                                </button>
                            </div>
                        `;
                        
                        // Add retry button functionality
                        combinedDetailsContainer.querySelector('.retry-btn')?.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            combinedDetailsContainer.innerHTML = '<p class="text-center">Loading details...</p>';
                            try {
                                const retryRequestDetails = await fetchRequestDetails(item.RequestID);
                                const retryDatasetDetails = await fetchDatasetDetails(item.DataSetID);
                                displayCombinedDetails(combinedDetailsContainer, retryRequestDetails, retryDatasetDetails);
                            } catch (retryError) {
                                combinedDetailsContainer.innerHTML = `
                                    <div class="p-3 bg-red-50 border border-red-200 rounded-md">
                                        <p class="text-red-600">Failed to load details</p>
                                        <p class="text-sm text-red-500 mt-1">${retryError.message || 'Unknown error'}</p>
                                    </div>
                                `;
                            }
                        });
                    }
                }
            });
            
            // Create accordion row
            const accordionRow = document.createElement('tr');
            accordionRow.classList.add('hidden', 'accordion-row');
            if (selectedStatus === 'Pending Approval') {
                accordionRow.innerHTML = `
                    <td colspan="${headers.length + 1}" class="p-0"> <!-- +1 for chevron column -->
                        <div class="bg-gray-50 p-4 m-2 rounded">
                            <div class="grid grid-cols-1 gap-4">
                                <div class="flex justify-end mb-1">
                                    <button class="btn btn-danger action-delete px-3 py-1" data-bs-toggle="modal" data-bs-target="#deleteRequestModal">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                        </svg>
                                        Delete
                                    </button>
                                </div>
                                
                                <!-- Combined Information Card -->
                                <div class="bg-white p-5 rounded-md shadow-sm">
                                    <div id="combined-details-${item.RequestID}" class="combined-content">
                                        <p class="text-center text-gray-500">Loading details...</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </td>
                `;
            } else {
                accordionRow.innerHTML = `
                    <td colspan="${headers.length + 1}" class="p-0"> <!-- +1 for chevron column -->
                        <div class="bg-gray-50 p-4 m-2 rounded">
                            <div class="grid grid-cols-1 gap-4">                            
                                <!-- Combined Information Card -->
                                <div class="bg-white p-5 rounded-md shadow-sm">
                                    <div id="combined-details-${item.RequestID}" class="combined-content">
                                        <p class="text-center text-gray-500">Loading details...</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </td>
                `;
            }

            
            // Add event listeners for the accordion
            const loadDatasetBtn = accordionRow.querySelector('.load-dataset-details');
            const deleteBtn = accordionRow.querySelector('.action-delete');
            loadDatasetBtn?.addEventListener('click', async (e) => {
                e.stopPropagation();
                // Your existing code for loading dataset details...
            });
            deleteBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                DeleteRequest(item);
            });
            tbody.appendChild(row);
            tbody.appendChild(accordionRow);
        });
    }
    
    table.appendChild(tbody);
    container.appendChild(table);
    
    // Add this style to your CSS or inline here
    const style = document.createElement('style');
    style.textContent = `
        .rotate-180 {
            transform: rotate(180deg);
        }
        .transition-transform {
            transition: transform 0.2s;
        }
    `;
    document.head.appendChild(style);
}


// =================================================================
//                     PRIMARY RENDER FUNCTION
// =================================================================

async function getCounts(status) {
    const apiParams = {
        "page": currentPage,
        "pageSize": rowsPerPage,
        "search": '',
        "statusId": parseInt(Object.keys(statusIdToNameMap).find(key => statusIdToNameMap[key] === status))
    }
    
    console.log(apiParams)
    const response = await window.loomeApi.runApiRequest(API_GET_REQUESTS, apiParams);
    const parsedResponse = safeParseJson(response);

    return parsedResponse.RowCount;
}

// Add this function to refresh all chip counts
async function refreshAllChipCounts() {
    const chipsContainer = document.getElementById('status-chips-container');
    for (const chip of chipsContainer.querySelectorAll('.chip')) {
        const status = chip.dataset.status;
        const count = await getCounts(status);
        chip.querySelector('.chip-count').textContent = count;
    }
}

/**
 * Main function to orchestrate all rendering based on the current state.
 * It filters, paginates, and renders the table and controls.
 */
async function renderUI() {
    const activeChip = document.querySelector('.chip.active');
    if (!activeChip) return; // Don't render if no chip is active
    
    const selectedStatus = activeChip.dataset.status;
    const searchInput = getSearchInput();
    const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';

    // --- 1. FETCH ALL DATA ONCE ---
    // We call the API without pagination params, assuming it returns all records.
    // If your API requires pagination, you'd need to fetch all pages in a loop here.
    const apiParams = {
        "page": currentPage,
        "pageSize": rowsPerPage,
        "search": searchTerm,
        "statusId": parseInt(Object.keys(statusIdToNameMap).find(key => statusIdToNameMap[key] === selectedStatus))
    }
    
    console.log(apiParams)
    const response = await window.loomeApi.runApiRequest(API_GET_REQUESTS, apiParams);
    const parsedResponse = safeParseJson(response)
    const rawData = parsedResponse.Results;
    const totalItems = parsedResponse.RowCount;
    console.log(rawData)

    // --- 2. PREPARE THE MASTER DATA ARRAY ---
    // Transform the raw data just once into the format our UI needs.
    allRequests = rawData.map(item => ({
        ...item,
        status: statusIdToNameMap[item.StatusID] || 'Unknown'
    }));
    console.log(allRequests)

    // --- Render the components ---
    const configForTable = configMap[selectedStatus];
    renderTable(TABLE_CONTAINER_ID, allRequests, configForTable, selectedStatus);
    renderPagination('pagination-controls', totalItems, rowsPerPage, currentPage);
}

// =================================================================
//                      INITIALIZATION
// =================================================================

/**
 * Main function to initialize the page, fetch all data, and set up listeners.
 */
async function renderMyRequestsPage() {
    try {

        // --- 3. UPDATE ALL CHIP COUNTS ONCE ---
        // This is the logic you wanted. It calculates counts from the unfiltered master array.
        const chipsContainer = document.getElementById('status-chips-container');
        for (const chip of chipsContainer.querySelectorAll('.chip')) {
            const status = chip.dataset.status;
            console.log(status)
            // Await the asynchronous getCounts function for each chip
            const count = await getCounts(status);
            chip.querySelector('.chip-count').textContent = count;
        }

        // --- 4. SETUP EVENT LISTENERS ---
        
        // Listener for status chip clicks
        chipsContainer.addEventListener('click', (event) => {
            const clickedChip = event.target.closest('.chip');
            if (!clickedChip) return;

            chipsContainer.querySelectorAll('.chip').forEach(chip => chip.classList.remove('active'));
            clickedChip.classList.add('active');
            
            currentPage = 1; // Reset to page 1 when changing tabs
            renderUI(); // Re-render everything
        });

        // Listener for the search input
        const searchInputEl = getSearchInput();
        if (searchInputEl) {
            searchInputEl.addEventListener('input', () => {
                currentPage = 1; // Reset to page 1 when searching
                renderUI(); // Re-render everything
            });
        }

        // Listener for pagination controls
        const paginationContainer = document.getElementById('pagination-controls');
        
        // Handle button clicks
        paginationContainer.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-page]');
            if (!button || button.disabled) return;
            
            currentPage = parseInt(button.dataset.page, 10);
            renderUI(); // Re-render everything
        });

        // Handle page input
        paginationContainer.addEventListener('keydown', (event) => {
            // Only act if the user pressed Enter and the target is our input
            if (event.key === 'Enter' && event.target.id === 'page-input') {
                const newPage = parseInt(event.target.value, 10);
                if (!isNaN(newPage) && newPage > 0) {
                    currentPage = newPage;
                    renderUI();
                }
            }
        });

        // --- 5. INITIAL PAGE RENDER ---
        // Programmatically click the first chip to trigger the initial render.
        document.querySelector('.chip[data-status="Pending Approval"]').click();

    } catch (error) {
        console.error("Error setting up the page:", error);
        // ... your error handling ...
    }
}

// Start the application (only in browser, not in test environment)
if (typeof jest === 'undefined') {
    renderMyRequestsPage();
}

// =================================================================
//                      MODULE EXPORTS (for testing)
// =================================================================
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        // Constants
        TABLE_CONTAINER_ID,
        API_GET_REQUESTS,
        API_DELETE_REQUEST,
        API_GET_REQUEST_DETAILS,
        API_GET_DATASET_DETAILS,
        API_GET_ASSIST_PROJECTS,
        statusIdToNameMap,
        configMap,
        rowsPerPage,
        // State accessors
        getAllRequests: () => allRequests,
        setAllRequests: (val) => { allRequests = val; },
        getCurrentPage: () => currentPage,
        setCurrentPage: (val) => { currentPage = val; },
        getProjectsCache: () => projectsCache,
        setProjectsCache: (val) => { projectsCache = val; },
        // Helper functions
        getSearchInput,
        // Utility functions
        safeParseJson,
        formatDate,
        getDataSourceName,
        formatFieldsForAccordion,
        // Toast functions
        showToast,
        hideToast,
        createToastContainer,
        // API functions
        fetchRequestDetails,
        fetchDatasetDetails,
        getProjectsMapping,
        deleteRequestFromAPI,
        getCounts,
        refreshAllChipCounts,
        // Display functions
        displayRequestDetails,
        displayDatasetDetails,
        displayCombinedDetails,
        // Render functions
        renderPagination,
        renderTable,
        renderUI,
        // Modal functions
        ViewRequest,
        ViewDataSet,
        DeleteRequest,
        // Initialization
        renderMyRequestsPage
    };
}

// =================================================================
//                      UNIT TESTS
// =================================================================
if (typeof describe !== 'undefined') {

const {
    TABLE_CONTAINER_ID: TEST_TABLE_CONTAINER_ID,
    API_GET_REQUESTS: TEST_API_GET_REQUESTS,
    API_DELETE_REQUEST: TEST_API_DELETE_REQUEST,
    API_GET_REQUEST_DETAILS: TEST_API_GET_REQUEST_DETAILS,
    API_GET_DATASET_DETAILS: TEST_API_GET_DATASET_DETAILS,
    API_GET_ASSIST_PROJECTS: TEST_API_GET_ASSIST_PROJECTS,
    statusIdToNameMap: testStatusIdToNameMap,
    configMap: testConfigMap,
    rowsPerPage: testRowsPerPage,
    getAllRequests,
    setAllRequests,
    getCurrentPage,
    setCurrentPage,
    getProjectsCache,
    setProjectsCache,
    getSearchInput: testGetSearchInput,
    safeParseJson: testSafeParseJson,
    formatDate: testFormatDate,
    getDataSourceName: testGetDataSourceName,
    formatFieldsForAccordion: testFormatFieldsForAccordion,
    showToast: testShowToast,
    hideToast: testHideToast,
    createToastContainer: testCreateToastContainer,
    fetchRequestDetails: testFetchRequestDetails,
    fetchDatasetDetails: testFetchDatasetDetails,
    getProjectsMapping: testGetProjectsMapping,
    deleteRequestFromAPI: testDeleteRequestFromAPI,
    getCounts: testGetCounts,
    refreshAllChipCounts: testRefreshAllChipCounts,
    displayRequestDetails: testDisplayRequestDetails,
    displayDatasetDetails: testDisplayDatasetDetails,
    displayCombinedDetails: testDisplayCombinedDetails,
    renderPagination: testRenderPagination,
    renderTable: testRenderTable,
    renderUI: testRenderUI,
    ViewRequest: testViewRequest,
    ViewDataSet: testViewDataSet,
    DeleteRequest: testDeleteRequest,
    renderMyRequestsPage: testRenderMyRequestsPage
} = module.exports;

// Mock API responses based on provided schemas
const mockGetRequestsResponse = {
    CurrentPage: 1,
    PageCount: 2,
    PageSize: 5,
    RowCount: 8,
    FirstRowOnPage: 1,
    LastRowOnPage: 5,
    Results: [
        {
            RequestID: 101,
            Name: 'Test Request 1',
            Description: 'Test description 1',
            CreateDate: '2025-01-10T10:00:00Z',
            CreateUser: 'user1@test.com',
            ModifiedDate: '2025-01-10T12:00:00Z',
            ApprovedDate: null,
            RejectedDate: null,
            FinalisedDate: null,
            StatusID: 1,
            ProjectID: 1,
            DataSetID: 10,
            Approvers: 'approver1@test.com',
            CurrentlyApproved: null,
            RejectedBy: null
        },
        {
            RequestID: 102,
            Name: 'Approved Request',
            Description: 'Approved desc',
            CreateDate: '2025-01-08T09:00:00Z',
            CreateUser: 'user2@test.com',
            ModifiedDate: '2025-01-09T14:00:00Z',
            ApprovedDate: '2025-01-09T14:00:00Z',
            RejectedDate: null,
            FinalisedDate: null,
            StatusID: 2,
            ProjectID: 2,
            DataSetID: 11,
            Approvers: 'approver2@test.com',
            CurrentlyApproved: 'approver2@test.com',
            RejectedBy: null
        }
    ]
};

const mockDeleteRequestResponse = {
    RequestID: 101,
    Name: 'Test Request 1',
    Description: 'Test description 1',
    CreateDate: '2025-01-10T10:00:00Z',
    CreateUser: 'user1@test.com',
    ModifiedDate: '2025-01-10T12:00:00Z',
    ApprovedDate: null,
    RejectedDate: null,
    FinalisedDate: null,
    StatusID: 1,
    ProjectID: 1,
    DataSetID: 10,
    Approvers: 'approver1@test.com',
    CurrentlyApproved: null,
    RejectedBy: null
};

const mockGetRequestIDResponse = {
    RequestID: 101,
    Name: 'Test Request 1',
    Description: 'Test description 1',
    CreateDate: '2025-01-10T10:00:00Z',
    CreateUser: 'user1@test.com',
    ModifiedDate: '2025-01-10T12:00:00Z',
    ApprovedDate: null,
    RejectedDate: null,
    FinalisedDate: null,
    StatusID: 1,
    ProjectID: 1,
    DataSetID: 10,
    Approvers: 'approver1@test.com',
    CurrentlyApproved: null,
    RejectedBy: null
};

const mockGetDataSetIDResponse = {
    Name: 'Test Dataset',
    Description: 'Dataset description',
    DataSourceID: 1,
    IsActive: true,
    Approvers: 'dataset-approver@test.com',
    OptOutMessage: 'Opt out message',
    OptOutList: null,
    Owner: 'owner@test.com',
    OptOutColumn: '-1',
    DataSetID: 10,
    ModifiedDate: '2025-01-10T12:00:00Z'
};

const mockGetAssistProjectsResponse = {
    CurrentPage: 1,
    PageCount: 1,
    PageSize: 10,
    RowCount: 2,
    FirstRowOnPage: 1,
    LastRowOnPage: 2,
    Results: [
        {
            AssistProjectID: 1,
            Name: 'Project Alpha',
            Description: 'Alpha project description',
            IsActive: true,
            ModifiedDate: '2025-01-05T10:00:00Z',
            LoomeAssistTenantsID: 'tenant-1'
        },
        {
            AssistProjectID: 2,
            Name: 'Project Beta',
            Description: null,
            IsActive: false,
            ModifiedDate: null,
            LoomeAssistTenantsID: null
        }
    ]
};

// =================================================================
// Test Suite
// =================================================================

describe('userrequests.js', () => {
    let mockApiRequest;

    beforeEach(() => {
        // Reset DOM
        document.body.innerHTML = `
            <div id="requests-table-area"></div>
            <div id="pagination-controls"></div>
            <input id="searchRequests" type="text" value="" />
            <div id="status-chips-container">
                <div class="chip active" data-status="Pending Approval"><span class="chip-count">0</span></div>
                <div class="chip" data-status="Approved"><span class="chip-count">0</span></div>
                <div class="chip" data-status="Rejected"><span class="chip-count">0</span></div>
                <div class="chip" data-status="Finalised"><span class="chip-count">0</span></div>
            </div>
            <div id="viewRequestModalBody"></div>
            <div id="viewDatasetModalBody"></div>
            <div id="deleteRequestModalBody"></div>
            <div id="deleteRequestModalLabel"></div>
        `;

        // Reset state
        setAllRequests([]);
        setCurrentPage(1);
        setProjectsCache(null);

        // Setup mock API
        mockApiRequest = jest.fn();
        window.loomeApi = { runApiRequest: mockApiRequest };

        // Mock console methods
        jest.spyOn(console, 'log').mockImplementation(() => {});
        jest.spyOn(console, 'warn').mockImplementation(() => {});
        jest.spyOn(console, 'error').mockImplementation(() => {});
    });

    afterEach(() => {
        jest.restoreAllMocks();
        delete window.loomeApi;
    });

    // =================================================================
    // Constants Tests
    // =================================================================
    describe('Constants', () => {
        test('TABLE_CONTAINER_ID should be defined', () => {
            expect(TEST_TABLE_CONTAINER_ID).toBe('requests-table-area');
        });

        test('API constants should be defined', () => {
            expect(TEST_API_GET_REQUESTS).toBe('GetRequests');
            expect(TEST_API_DELETE_REQUEST).toBe('DeleteRequestID');
            expect(TEST_API_GET_REQUEST_DETAILS).toBe('GetRequestID');
            expect(TEST_API_GET_DATASET_DETAILS).toBe('GetDataSetID');
            expect(TEST_API_GET_ASSIST_PROJECTS).toBe('GetAssistProjectsFilteredByUpn');
        });

        test('statusIdToNameMap should map status IDs correctly', () => {
            expect(testStatusIdToNameMap[1]).toBe('Pending Approval');
            expect(testStatusIdToNameMap[2]).toBe('Approved');
            expect(testStatusIdToNameMap[3]).toBe('Finalised');
            expect(testStatusIdToNameMap[4]).toBe('Rejected');
        });

        test('configMap should have configuration for each status', () => {
            expect(testConfigMap['Pending Approval']).toEqual({ showActions: true });
            expect(testConfigMap['Approved']).toEqual({ showActions: true });
            expect(testConfigMap['Rejected']).toEqual({ showActions: true });
            expect(testConfigMap['Finalised']).toEqual({ showActions: true });
        });

        test('rowsPerPage should be 5', () => {
            expect(testRowsPerPage).toBe(5);
        });
    });

    // =================================================================
    // State Accessor Tests
    // =================================================================
    describe('State Accessors', () => {
        test('getAllRequests and setAllRequests should work', () => {
            expect(getAllRequests()).toEqual([]);
            const testData = [{ RequestID: 1 }];
            setAllRequests(testData);
            expect(getAllRequests()).toEqual(testData);
        });

        test('getCurrentPage and setCurrentPage should work', () => {
            expect(getCurrentPage()).toBe(1);
            setCurrentPage(5);
            expect(getCurrentPage()).toBe(5);
        });

        test('getProjectsCache and setProjectsCache should work', () => {
            expect(getProjectsCache()).toBeNull();
            const cache = { 1: { name: 'Test' } };
            setProjectsCache(cache);
            expect(getProjectsCache()).toEqual(cache);
        });

        test('getSearchInput should return the search input element', () => {
            const input = testGetSearchInput();
            expect(input).not.toBeNull();
            expect(input.id).toBe('searchRequests');
        });
    });

    // =================================================================
    // safeParseJson Tests
    // =================================================================
    describe('safeParseJson', () => {
        test('should parse JSON string', () => {
            const result = testSafeParseJson('{"key": "value"}');
            expect(result).toEqual({ key: 'value' });
        });

        test('should return object as-is', () => {
            const obj = { key: 'value' };
            const result = testSafeParseJson(obj);
            expect(result).toBe(obj);
        });

        test('should handle complex JSON strings', () => {
            const jsonStr = JSON.stringify(mockGetRequestsResponse);
            const result = testSafeParseJson(jsonStr);
            expect(result).toEqual(mockGetRequestsResponse);
        });

        test('should throw on invalid JSON string', () => {
            expect(() => testSafeParseJson('invalid json')).toThrow();
        });

        test('should handle arrays', () => {
            const arr = [1, 2, 3];
            expect(testSafeParseJson(arr)).toBe(arr);
            expect(testSafeParseJson('[1,2,3]')).toEqual([1, 2, 3]);
        });
    });

    // =================================================================
    // formatDate Tests
    // =================================================================
    describe('formatDate', () => {
        test('should return N/A for null', () => {
            expect(testFormatDate(null)).toBe('N/A');
        });

        test('should return N/A for undefined', () => {
            expect(testFormatDate(undefined)).toBe('N/A');
        });

        test('should return N/A for empty string', () => {
            expect(testFormatDate('')).toBe('N/A');
        });

        test('should return N/A for invalid date string', () => {
            expect(testFormatDate('invalid date')).toBe('N/A');
        });

        test('should format valid ISO date string', () => {
            const result = testFormatDate('2025-01-10T10:00:00Z');
            expect(result).toContain('January');
            expect(result).toContain('10');
            expect(result).toContain('2025');
        });

        test('should format date object', () => {
            const date = new Date('2025-06-15');
            const result = testFormatDate(date);
            expect(result).toContain('June');
            expect(result).toContain('15');
            expect(result).toContain('2025');
        });

        test('should handle various date formats', () => {
            expect(testFormatDate('2025-12-25')).toContain('December');
            expect(testFormatDate('2025/03/01')).toContain('March');
        });
    });

    // =================================================================
    // getDataSourceName Tests
    // =================================================================
    describe('getDataSourceName', () => {
        test('should return BIS Data for ID 1', () => {
            expect(testGetDataSourceName(1)).toBe('BIS Data (pilot test)');
        });

        test('should return Barwon Health for ID 4', () => {
            expect(testGetDataSourceName(4)).toBe('Barwon Health DB Source View 1');
        });

        test('should return Source Mock SQL Data for ID 25', () => {
            expect(testGetDataSourceName(25)).toBe('Source Mock SQL Data for Testing');
        });

        test('should return Unknown Source for unknown ID', () => {
            expect(testGetDataSourceName(999)).toBe('Unknown Source (999)');
        });

        test('should handle zero', () => {
            expect(testGetDataSourceName(0)).toBe('Unknown Source (0)');
        });
    });

    // =================================================================
    // formatFieldsForAccordion Tests
    // =================================================================
    describe('formatFieldsForAccordion', () => {
        test('should return no fields message for null', () => {
            expect(testFormatFieldsForAccordion(null)).toBe('No fields available');
        });

        test('should return no fields message for undefined', () => {
            expect(testFormatFieldsForAccordion(undefined)).toBe('No fields available');
        });

        test('should return no fields message for empty array', () => {
            expect(testFormatFieldsForAccordion([])).toBe('No fields available');
        });

        test('should format fields into HTML table', () => {
            const fields = [
                { Name: 'Field1', Type: 'string' },
                { Name: 'Field2', Type: 'integer' }
            ];
            const result = testFormatFieldsForAccordion(fields);
            expect(result).toContain('<table');
            expect(result).toContain('Field1');
            expect(result).toContain('string');
            expect(result).toContain('Field2');
            expect(result).toContain('integer');
        });

        test('should include table headers', () => {
            const fields = [{ Name: 'Test', Type: 'text' }];
            const result = testFormatFieldsForAccordion(fields);
            expect(result).toContain('Field');
            expect(result).toContain('Type');
        });
    });

    // =================================================================
    // Toast Functions Tests
    // =================================================================
    describe('Toast Functions', () => {
        describe('createToastContainer', () => {
            test('should create a toast container', () => {
                const container = testCreateToastContainer();
                expect(container).not.toBeNull();
                expect(container.id).toBe('toast-container');
                expect(document.getElementById('toast-container')).toBe(container);
            });

            test('should have correct styles', () => {
                const container = testCreateToastContainer();
                expect(container.style.position).toBe('fixed');
                expect(container.style.zIndex).toBe('9999');
            });
        });

        describe('showToast', () => {
            test('should create and show info toast', () => {
                const toast = testShowToast('Test message', 'info');
                expect(toast).not.toBeNull();
                expect(toast.innerHTML).toContain('Test message');
            });

            test('should create success toast with green background', () => {
                const toast = testShowToast('Success!', 'success');
                expect(toast.style.backgroundColor).toContain('76');
            });

            test('should create error toast with red background', () => {
                const toast = testShowToast('Error!', 'error');
                expect(toast.style.backgroundColor).toContain('244');
            });

            test('should default to info type', () => {
                const toast = testShowToast('Default message');
                expect(toast.style.backgroundColor).toContain('33');
            });

            test('should append toast to container', () => {
                const toast = testShowToast('Test');
                const container = document.getElementById('toast-container');
                expect(container.contains(toast)).toBe(true);
            });
        });

        describe('hideToast', () => {
            test('should hide toast by setting opacity to 0', () => {
                const toast = testShowToast('Test');
                testHideToast(toast);
                expect(toast.style.opacity).toBe('0');
            });

            test('should handle null toast gracefully', () => {
                expect(() => testHideToast(null)).not.toThrow();
            });

            test('should handle toast without parent', () => {
                const toast = document.createElement('div');
                expect(() => testHideToast(toast)).not.toThrow();
            });
        });
    });

    // =================================================================
    // API Functions Tests
    // =================================================================
    describe('API Functions', () => {
        describe('fetchRequestDetails', () => {
            test('should fetch request details successfully', async () => {
                mockApiRequest.mockResolvedValue(mockGetRequestIDResponse);
                const result = await testFetchRequestDetails(101);
                expect(mockApiRequest).toHaveBeenCalledWith('GetRequestID', { RequestID: 101 });
                expect(result.RequestID).toBe(101);
            });

            test('should handle JSON string response', async () => {
                mockApiRequest.mockResolvedValue(JSON.stringify(mockGetRequestIDResponse));
                const result = await testFetchRequestDetails(101);
                expect(result.RequestID).toBe(101);
            });

            test('should throw on API error', async () => {
                mockApiRequest.mockRejectedValue(new Error('API Error'));
                await expect(testFetchRequestDetails(101)).rejects.toThrow('API Error');
            });
        });

        describe('fetchDatasetDetails', () => {
            test('should fetch dataset details successfully', async () => {
                mockApiRequest.mockResolvedValue(mockGetDataSetIDResponse);
                const result = await testFetchDatasetDetails(10);
                expect(mockApiRequest).toHaveBeenCalledWith('GetDataSetID', { DataSetID: 10 });
                expect(result.DataSetID).toBe(10);
            });

            test('should handle JSON string response', async () => {
                mockApiRequest.mockResolvedValue(JSON.stringify(mockGetDataSetIDResponse));
                const result = await testFetchDatasetDetails(10);
                expect(result.Name).toBe('Test Dataset');
            });

            test('should throw on API error', async () => {
                mockApiRequest.mockRejectedValue(new Error('Dataset error'));
                await expect(testFetchDatasetDetails(10)).rejects.toThrow('Dataset error');
            });
        });

        describe('getProjectsMapping', () => {
            test('should fetch and cache projects', async () => {
                setProjectsCache(null);
                mockApiRequest.mockResolvedValue(mockGetAssistProjectsResponse);
                const result = await testGetProjectsMapping();
                expect(mockApiRequest).toHaveBeenCalledWith('GetAssistProjectsFilteredByUpn');
                expect(result[1]).toEqual({ name: 'Project Alpha', description: 'Alpha project description' });
                expect(result[2]).toEqual({ name: 'Project Beta', description: null });
            });

            test('should return cached projects on subsequent calls', async () => {
                const cache = { 5: { name: 'Cached Project', description: 'Cached' } };
                setProjectsCache(cache);
                const result = await testGetProjectsMapping();
                expect(mockApiRequest).not.toHaveBeenCalled();
                expect(result).toBe(cache);
            });

            test('should return empty object on API error', async () => {
                setProjectsCache(null);
                mockApiRequest.mockRejectedValue(new Error('API Error'));
                const result = await testGetProjectsMapping();
                expect(result).toEqual({});
            });

            test('should handle response with empty Results array', async () => {
                setProjectsCache(null);
                mockApiRequest.mockResolvedValue({ Results: [] });
                const result = await testGetProjectsMapping();
                expect(result).toEqual({});
            });
        });

        describe('getCounts', () => {
            test('should get count for Pending Approval status', async () => {
                mockApiRequest.mockResolvedValue({ RowCount: 5 });
                const result = await testGetCounts('Pending Approval');
                expect(result).toBe(5);
                expect(mockApiRequest).toHaveBeenCalledWith('GetRequests', expect.objectContaining({
                    statusId: 1
                }));
            });

            test('should get count for Approved status', async () => {
                mockApiRequest.mockResolvedValue({ RowCount: 10 });
                const result = await testGetCounts('Approved');
                expect(result).toBe(10);
                expect(mockApiRequest).toHaveBeenCalledWith('GetRequests', expect.objectContaining({
                    statusId: 2
                }));
            });

            test('should get count for Finalised status', async () => {
                mockApiRequest.mockResolvedValue({ RowCount: 3 });
                const result = await testGetCounts('Finalised');
                expect(result).toBe(3);
                expect(mockApiRequest).toHaveBeenCalledWith('GetRequests', expect.objectContaining({
                    statusId: 3
                }));
            });

            test('should get count for Rejected status', async () => {
                mockApiRequest.mockResolvedValue({ RowCount: 2 });
                const result = await testGetCounts('Rejected');
                expect(result).toBe(2);
                expect(mockApiRequest).toHaveBeenCalledWith('GetRequests', expect.objectContaining({
                    statusId: 4
                }));
            });
        });

        describe('deleteRequestFromAPI', () => {
            beforeEach(() => {
                // Add bootstrap mock
                window.bootstrap = {
                    Modal: {
                        getInstance: jest.fn().mockReturnValue({
                            hide: jest.fn()
                        })
                    }
                };
            });

            afterEach(() => {
                delete window.bootstrap;
            });

            test('should call delete API with request ID', async () => {
                mockApiRequest.mockResolvedValue(mockDeleteRequestResponse);
                await testDeleteRequestFromAPI(101);
                expect(mockApiRequest).toHaveBeenCalledWith('DeleteRequestID', { id: 101 });
            });

            test('should show success toast on successful deletion', async () => {
                mockApiRequest.mockResolvedValue(mockDeleteRequestResponse);
                await testDeleteRequestFromAPI(101);
                const toasts = document.querySelectorAll('#toast-container > div');
                expect(toasts.length).toBeGreaterThan(0);
            });

            test('should show error toast on API error', async () => {
                mockApiRequest.mockRejectedValue(new Error('Delete failed'));
                await testDeleteRequestFromAPI(101);
                const container = document.getElementById('toast-container');
                expect(container.innerHTML).toContain('Failed to delete request');
            });
        });

        describe('refreshAllChipCounts', () => {
            test('should update all chip counts', async () => {
                mockApiRequest
                    .mockResolvedValueOnce({ RowCount: 5 })
                    .mockResolvedValueOnce({ RowCount: 10 })
                    .mockResolvedValueOnce({ RowCount: 2 })
                    .mockResolvedValueOnce({ RowCount: 7 });

                await testRefreshAllChipCounts();

                const chips = document.querySelectorAll('.chip');
                expect(chips[0].querySelector('.chip-count').textContent).toBe('5');
                expect(chips[1].querySelector('.chip-count').textContent).toBe('10');
                expect(chips[2].querySelector('.chip-count').textContent).toBe('2');
                expect(chips[3].querySelector('.chip-count').textContent).toBe('7');
            });
        });
    });

    // =================================================================
    // Display Functions Tests
    // =================================================================
    describe('Display Functions', () => {
        describe('displayRequestDetails', () => {
            test('should display no details message for empty object', async () => {
                setProjectsCache(null);
                const container = document.createElement('div');
                await testDisplayRequestDetails(container, {});
                expect(container.innerHTML).toContain('No request details available');
            });

            test('should display no details message for null', async () => {
                const container = document.createElement('div');
                await testDisplayRequestDetails(container, null);
                expect(container.innerHTML).toContain('No request details available');
            });

            test('should display project name from mapping', async () => {
                setProjectsCache({ 1: { name: 'Test Project', description: 'Test Desc' } });
                const container = document.createElement('div');
                await testDisplayRequestDetails(container, { ProjectID: 1, Name: 'Request' });
                expect(container.innerHTML).toContain('Test Project');
            });

            test('should show Unknown Project for missing project', async () => {
                setProjectsCache({});
                const container = document.createElement('div');
                await testDisplayRequestDetails(container, { ProjectID: 999, Name: 'Request' });
                expect(container.innerHTML).toContain('Unknown Project');
            });

            test('should display project description if available', async () => {
                setProjectsCache({ 1: { name: 'Project', description: 'Project Description' } });
                const container = document.createElement('div');
                await testDisplayRequestDetails(container, { ProjectID: 1 });
                expect(container.innerHTML).toContain('Project Description');
            });
        });

        describe('displayDatasetDetails', () => {
            test('should display no details message for empty object', () => {
                const container = document.createElement('div');
                testDisplayDatasetDetails(container, {});
                expect(container.innerHTML).toContain('No dataset details available');
            });

            test('should display no details message for null', () => {
                const container = document.createElement('div');
                testDisplayDatasetDetails(container, null);
                expect(container.innerHTML).toContain('No dataset details available');
            });

            test('should display dataset basic info', () => {
                const container = document.createElement('div');
                testDisplayDatasetDetails(container, {
                    Name: 'Test Dataset',
                    Description: 'Test Description',
                    DataSourceID: 1
                });
                expect(container.innerHTML).toContain('Test Dataset');
                expect(container.innerHTML).toContain('Test Description');
            });

            test('should display N/A for missing values', () => {
                const container = document.createElement('div');
                testDisplayDatasetDetails(container, { DataSourceID: 1 });
                expect(container.innerHTML).toContain('N/A');
            });

            test('should display fields table if fields exist', () => {
                const container = document.createElement('div');
                testDisplayDatasetDetails(container, {
                    Name: 'Dataset',
                    Fields: [
                        { Name: 'Field1', Type: 'string', Description: 'Desc1' },
                        { Name: 'Field2', Type: 'int', Description: '' }
                    ]
                });
                expect(container.innerHTML).toContain('Field1');
                expect(container.innerHTML).toContain('string');
                expect(container.innerHTML).toContain('Field2');
            });
        });

        describe('displayCombinedDetails', () => {
            test('should display no details for both empty', async () => {
                const container = document.createElement('div');
                await testDisplayCombinedDetails(container, {}, {});
                expect(container.innerHTML).toContain('No details available');
            });

            test('should display combined request and dataset details', async () => {
                setProjectsCache({ 1: { name: 'Combined Project', description: 'Desc' } });
                const container = document.createElement('div');
                await testDisplayCombinedDetails(container, 
                    { ProjectID: 1, Name: 'Request' },
                    { Name: 'Dataset Name', Description: 'Dataset Desc', DataSourceID: 1 }
                );
                expect(container.innerHTML).toContain('Combined Project');
                expect(container.innerHTML).toContain('Dataset Name');
                expect(container.innerHTML).toContain('Dataset Desc');
            });

            test('should handle missing project mapping', async () => {
                setProjectsCache({});
                const container = document.createElement('div');
                await testDisplayCombinedDetails(container,
                    { ProjectID: 999 },
                    { Name: 'Dataset' }
                );
                expect(container.innerHTML).toContain('Unknown Project');
            });

            test('should handle API error in getProjectsMapping gracefully', async () => {
                setProjectsCache(null);
                mockApiRequest.mockRejectedValue(new Error('Test error'));
                const container = document.createElement('div');
                await testDisplayCombinedDetails(container,
                    { ProjectID: 1 },
                    { Name: 'Dataset' }
                );
                // When API fails, getProjectsMapping returns {} and displays "Unknown Project"
                expect(container.innerHTML).toContain('Unknown Project');
            });
        });
    });

    // =================================================================
    // Render Functions Tests
    // =================================================================
    describe('Render Functions', () => {
        describe('renderPagination', () => {
            test('should render nothing for single page', () => {
                testRenderPagination('pagination-controls', 3, 5, 1);
                const container = document.getElementById('pagination-controls');
                expect(container.innerHTML).toBe('');
            });

            test('should render pagination for multiple pages', () => {
                testRenderPagination('pagination-controls', 15, 5, 1);
                const container = document.getElementById('pagination-controls');
                expect(container.innerHTML).toContain('First');
                expect(container.innerHTML).toContain('Previous');
                expect(container.innerHTML).toContain('Next');
                expect(container.innerHTML).toContain('Last');
            });

            test('should disable First and Previous on first page', () => {
                testRenderPagination('pagination-controls', 15, 5, 1);
                const container = document.getElementById('pagination-controls');
                const buttons = container.querySelectorAll('button');
                expect(buttons[0].disabled).toBe(true);
                expect(buttons[1].disabled).toBe(true);
            });

            test('should disable Next and Last on last page', () => {
                testRenderPagination('pagination-controls', 15, 5, 3);
                const container = document.getElementById('pagination-controls');
                const buttons = container.querySelectorAll('button');
                expect(buttons[2].disabled).toBe(true);
                expect(buttons[3].disabled).toBe(true);
            });

            test('should show correct page number in input', () => {
                testRenderPagination('pagination-controls', 20, 5, 2);
                const input = document.getElementById('page-input');
                expect(input.value).toBe('2');
            });

            test('should handle missing container gracefully', () => {
                expect(() => testRenderPagination('nonexistent', 10, 5, 1)).not.toThrow();
            });

            test('should show total pages', () => {
                testRenderPagination('pagination-controls', 25, 5, 1);
                const container = document.getElementById('pagination-controls');
                expect(container.innerHTML).toContain('of 5');
            });
        });

        describe('renderTable', () => {
            test('should render empty table message when no data', () => {
                testRenderTable('requests-table-area', [], { showActions: true }, 'Pending Approval');
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('No requests found');
            });

            test('should render table with data', () => {
                const data = [{
                    RequestID: 1,
                    Name: 'Test Request',
                    CreateDate: '2025-01-10T10:00:00Z',
                    status: 'Pending Approval',
                    Approvers: 'approver@test.com',
                    DataSetID: 10
                }];
                testRenderTable('requests-table-area', data, { showActions: true }, 'Pending Approval');
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Test Request');
                expect(container.innerHTML).toContain('1');
            });

            test('should render Pending Approval specific columns', () => {
                const data = [{
                    RequestID: 1,
                    Name: 'Request',
                    CreateDate: '2025-01-10',
                    status: 'Pending Approval',
                    Approvers: 'approver@test.com',
                    DataSetID: 10
                }];
                testRenderTable('requests-table-area', data, {}, 'Pending Approval');
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Approvers');
                expect(container.innerHTML).toContain('approver@test.com');
            });

            test('should render Approved status columns', () => {
                const data = [{
                    RequestID: 1,
                    Name: 'Request',
                    CreateDate: '2025-01-10',
                    status: 'Approved',
                    CurrentlyApproved: 'approver@test.com',
                    ApprovedDate: '2025-01-11',
                    DataSetID: 10
                }];
                testRenderTable('requests-table-area', data, {}, 'Approved');
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Approved by');
                expect(container.innerHTML).toContain('Approved on');
            });

            test('should render Rejected status columns', () => {
                const data = [{
                    RequestID: 1,
                    Name: 'Request',
                    CreateDate: '2025-01-10',
                    status: 'Rejected',
                    RejectedBy: 'rejector@test.com',
                    RejectedDate: '2025-01-12',
                    DataSetID: 10
                }];
                testRenderTable('requests-table-area', data, {}, 'Rejected');
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Rejected by');
                expect(container.innerHTML).toContain('Rejected on');
            });

            test('should render Finalised status columns', () => {
                const data = [{
                    RequestID: 1,
                    Name: 'Request',
                    CreateDate: '2025-01-10',
                    status: 'Finalised',
                    CurrentlyApproved: 'approver@test.com',
                    ApprovedDate: '2025-01-11',
                    FinalisedDate: '2025-01-12',
                    DataSetID: 10
                }];
                testRenderTable('requests-table-area', data, {}, 'Finalised');
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Finalised on');
            });

            test('should create accordion rows', () => {
                const data = [{
                    RequestID: 1,
                    Name: 'Request',
                    CreateDate: '2025-01-10',
                    status: 'Pending Approval',
                    Approvers: 'test@test.com',
                    DataSetID: 10
                }];
                testRenderTable('requests-table-area', data, {}, 'Pending Approval');
                const container = document.getElementById('requests-table-area');
                expect(container.querySelectorAll('.accordion-row').length).toBe(1);
            });

            test('should show delete button for Pending Approval status', () => {
                const data = [{
                    RequestID: 1,
                    Name: 'Request',
                    CreateDate: '2025-01-10',
                    status: 'Pending Approval',
                    Approvers: 'test@test.com',
                    DataSetID: 10
                }];
                testRenderTable('requests-table-area', data, {}, 'Pending Approval');
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Delete');
            });
        });

        describe('renderUI', () => {
            test('should not render if no active chip', async () => {
                document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
                await testRenderUI();
                expect(mockApiRequest).not.toHaveBeenCalled();
            });

            test('should fetch data and render table', async () => {
                mockApiRequest.mockResolvedValue(mockGetRequestsResponse);
                await testRenderUI();
                expect(mockApiRequest).toHaveBeenCalledWith('GetRequests', expect.any(Object));
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('table');
            });

            test('should transform data with status names', async () => {
                mockApiRequest.mockResolvedValue(mockGetRequestsResponse);
                await testRenderUI();
                const requests = getAllRequests();
                expect(requests[0].status).toBe('Pending Approval');
                expect(requests[1].status).toBe('Approved');
            });

            test('should include search term in API params', async () => {
                const searchInput = document.getElementById('searchRequests');
                searchInput.value = 'test search';
                mockApiRequest.mockResolvedValue(mockGetRequestsResponse);
                await testRenderUI();
                expect(mockApiRequest).toHaveBeenCalledWith('GetRequests', expect.objectContaining({
                    search: 'test search'
                }));
            });
        });
    });

    // =================================================================
    // Modal Functions Tests
    // =================================================================
    describe('Modal Functions', () => {
        describe('ViewRequest', () => {
            test('should populate view request modal', () => {
                testViewRequest({ name: 'Test Request' });
                const modalBody = document.getElementById('viewRequestModalBody');
                expect(modalBody.innerHTML).toContain('Test Request');
                expect(modalBody.innerHTML).toContain('Request Name');
            });

            test('should include schedule refresh options', () => {
                testViewRequest({ name: 'Request' });
                const modalBody = document.getElementById('viewRequestModalBody');
                expect(modalBody.innerHTML).toContain('No Refresh');
                expect(modalBody.innerHTML).toContain('Daily');
                expect(modalBody.innerHTML).toContain('Weekly');
                expect(modalBody.innerHTML).toContain('Monthly');
            });
        });

        describe('ViewDataSet', () => {
            test('should fetch and return formatted dataset details', async () => {
                mockApiRequest.mockResolvedValue({
                    DataSetID: 10,
                    Name: 'Test Dataset',
                    Description: 'Description',
                    DataSourceID: 1,
                    Active: true,
                    Fields: [{ Name: 'Field1', Type: 'string' }]
                });
                const result = await testViewDataSet({ DataSetID: 10 });
                expect(result.Name).toBe('Test Dataset');
                expect(result.DataSource).toBe('BIS Data (pilot test)');
            });

            test('should handle missing description', async () => {
                mockApiRequest.mockResolvedValue({
                    DataSetID: 10,
                    Name: 'Dataset',
                    DataSourceID: 1,
                    Fields: []
                });
                const result = await testViewDataSet({ DataSetID: 10 });
                expect(result.Description).toBe('No description available');
            });

            test('should reject on API error', async () => {
                mockApiRequest.mockRejectedValue(new Error('Fetch failed'));
                await expect(testViewDataSet({ DataSetID: 10 })).rejects.toThrow('Fetch failed');
            });
        });

        describe('DeleteRequest', () => {
            test('should populate delete modal with request name', () => {
                testDeleteRequest({ Name: 'Request To Delete', RequestID: 101 });
                const modalBody = document.getElementById('deleteRequestModalBody');
                const modalTitle = document.getElementById('deleteRequestModalLabel');
                expect(modalBody.innerHTML).toContain('Request To Delete');
                expect(modalTitle.textContent).toBe('Delete Request');
            });

            test('should show warning message', () => {
                testDeleteRequest({ Name: 'Test', RequestID: 1 });
                const modalBody = document.getElementById('deleteRequestModalBody');
                expect(modalBody.innerHTML).toContain('You are about to delete');
            });

            test('should include delete button', () => {
                testDeleteRequest({ Name: 'Test', RequestID: 1 });
                const modalBody = document.getElementById('deleteRequestModalBody');
                expect(modalBody.innerHTML).toContain('confirmDeleteBtn');
            });
        });
    });

    // =================================================================
    // Initialization Tests
    // =================================================================
    describe('Initialization', () => {
        describe('renderMyRequestsPage', () => {
            test('should set up chip counts', async () => {
                mockApiRequest
                    .mockResolvedValueOnce({ RowCount: 5 })
                    .mockResolvedValueOnce({ RowCount: 10 })
                    .mockResolvedValueOnce({ RowCount: 2 })
                    .mockResolvedValueOnce({ RowCount: 7 })
                    .mockResolvedValue(mockGetRequestsResponse);

                await testRenderMyRequestsPage();

                const chips = document.querySelectorAll('.chip');
                expect(chips[0].querySelector('.chip-count').textContent).toBe('5');
            });

            test('should set up event listeners for chips', async () => {
                mockApiRequest.mockResolvedValue({ RowCount: 0, Results: [] });

                await testRenderMyRequestsPage();

                const approvedChip = document.querySelector('.chip[data-status="Approved"]');
                approvedChip.click();

                expect(approvedChip.classList.contains('active')).toBe(true);
            });
        });
    });

    // =================================================================
    // Integration Tests
    // =================================================================
    describe('Integration Tests', () => {
        test('should handle full page load workflow', async () => {
            mockApiRequest
                .mockResolvedValueOnce({ RowCount: 3 })
                .mockResolvedValueOnce({ RowCount: 5 })
                .mockResolvedValueOnce({ RowCount: 1 })
                .mockResolvedValueOnce({ RowCount: 2 })
                .mockResolvedValue({
                    ...mockGetRequestsResponse,
                    RowCount: 3
                });

            await testRenderMyRequestsPage();

            // Verify chip counts were set correctly
            const chips = document.querySelectorAll('.chip');
            expect(chips[0].querySelector('.chip-count').textContent).toBe('3');
            expect(chips[1].querySelector('.chip-count').textContent).toBe('5');
        });

        test('should handle status switching', async () => {
            mockApiRequest.mockResolvedValue({ RowCount: 0, Results: [] });

            await testRenderMyRequestsPage();

            const rejectedChip = document.querySelector('.chip[data-status="Rejected"]');
            rejectedChip.click();

            expect(getCurrentPage()).toBe(1);
        });

        test('should handle search functionality', async () => {
            mockApiRequest.mockResolvedValue({ RowCount: 0, Results: [] });

            await testRenderMyRequestsPage();

            const searchInput = document.getElementById('searchRequests');
            searchInput.value = 'test query';
            searchInput.dispatchEvent(new Event('input'));

            expect(getCurrentPage()).toBe(1);
        });
    });

    // =================================================================
    // Edge Cases Tests
    // =================================================================
    describe('Edge Cases', () => {
        test('should handle API returning null Results', async () => {
            mockApiRequest.mockResolvedValue({ RowCount: 0, Results: null });
            document.querySelector('.chip.active').dataset.status = 'Pending Approval';
            
            // This should not throw
            await expect(testRenderUI()).rejects.toThrow();
        });

        test('should handle unknown status ID', async () => {
            mockApiRequest.mockResolvedValue({
                RowCount: 1,
                Results: [{
                    RequestID: 1,
                    Name: 'Unknown Status Request',
                    StatusID: 99,
                    CreateDate: '2025-01-10',
                    DataSetID: 1
                }]
            });

            await testRenderUI();
            const requests = getAllRequests();
            expect(requests[0].status).toBe('Unknown');
        });

        test('should handle missing approvers in request', () => {
            const data = [{
                RequestID: 1,
                Name: 'No Approvers',
                CreateDate: '2025-01-10',
                status: 'Pending Approval',
                Approvers: null,
                DataSetID: 10
            }];
            testRenderTable('requests-table-area', data, {}, 'Pending Approval');
            const container = document.getElementById('requests-table-area');
            expect(container.innerHTML).toContain('N/A');
        });

        test('should handle missing CurrentlyApproved in approved request', () => {
            const data = [{
                RequestID: 1,
                Name: 'Approved Request',
                CreateDate: '2025-01-10',
                status: 'Approved',
                CurrentlyApproved: null,
                ApprovedDate: null,
                DataSetID: 10
            }];
            testRenderTable('requests-table-area', data, {}, 'Approved');
            const container = document.getElementById('requests-table-area');
            expect(container.innerHTML).toContain('N/A');
        });

        test('should handle zero row count for pagination', () => {
            testRenderPagination('pagination-controls', 0, 5, 1);
            const container = document.getElementById('pagination-controls');
            expect(container.innerHTML).toBe('');
        });

        test('should handle large page numbers', () => {
            testRenderPagination('pagination-controls', 1000, 5, 100);
            const container = document.getElementById('pagination-controls');
            expect(container.innerHTML).toContain('of 200');
        });
    });
});

} // End of test block
