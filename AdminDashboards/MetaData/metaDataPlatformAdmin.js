// Generated by Copilot
// Define the single container ID for the table
const TABLE_CONTAINER_ID = 'requests-table-area';
const API_GET_METADATA = 'GetMetadata';
const API_ADD_METADATA = 'AddMetaData';
const API_UPDATE_METADATA = 'UpdateMetaData';

// --- STATE MANAGEMENT ---
// These variables need to be accessible by multiple functions.
let currentPage = 1;
let rowsPerPage = 5; // Default, will be updated by API response
let tableConfig = {}; // Will hold your headers configuration
const searchInput = document.getElementById('searchRequests');


/**
 * Displays a temporary "toast" notification on the screen.
 * @param {string} message - The message to display.
 * @param {string} [type='success'] - The type of toast ('success', 'error', 'info').
 * @param {number} [duration=3000] - How long the toast should be visible in milliseconds.
 */
function showToast(message, type = 'success', duration = 3000) {
    // Create the toast element
    const toast = document.createElement('div');
    toast.className = `toast-notification toast-${type}`;
    toast.textContent = message;

    // Basic styling (add this to your CSS file for better results)
    const style = document.createElement('style');
    document.head.appendChild(style);
    style.sheet.insertRule(`
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: #fff;
            font-family: sans-serif;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(-20px);
        }
    `);
    style.sheet.insertRule('.toast-success { background-color: #28a745; }'); // Green
    style.sheet.insertRule('.toast-error { background-color: #dc3545; }');   // Red

    // Append to body and trigger animation
    document.body.appendChild(toast);
    setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateY(0)';
    }, 10); // A tiny delay to allow the CSS transition to work

    // Set a timer to remove the toast
    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(-20px)';
        // Remove the element from the DOM after the fade-out animation
        toast.addEventListener('transitionend', () => toast.remove());
    }, duration);
}

function AddMetadata() {
    // Get the modal's body element
    const modalBody = document.getElementById('addMetaDataModalBody');
    console.log("IN add Metadata")

    // Populate the modal body with the provided HTML content (your markup)
    modalBody.innerHTML = `
                <form id="addMetaDataForm">
                        <!-- Name Field -->
                        <div class="mb-3">
                            <label for="Name" class="form-label">Name</label>
                            <input id="metaDataName" placeholder="Name for this Meta Data" class="form-control">
                        </div>

                        <!-- Description Field -->
                        <div class="mb-3">
                            <label for="Description" class="form-label">Description</label>
                            <textarea rows="2" id="metaDataDescription" placeholder="Description of this Meta Data" class="form-control"></textarea>
                        </div>

                        <!-- Active Checkbox -->
                        <div class="mb-3 form-check">
                            <input type="checkbox" id="metaDataActive" class="form-check-input" checked>
                            <label class="form-check-label" for="metaDataActive">Active</label>
                        </div>

                    </form>
            
    `;
    
}

/**
 * Gathers all data from the "Add Data Source" modal form.
 * It handles both static fields and dynamically generated fields.
 *
 * @param {HTMLElement} formElement - The <form> element to read data from.
 * @returns {object | null} An object containing the structured form data, or null if the form is not found.
 */
function getMetaDataFormData(formElement) {
    if (!formElement) {
        console.error("Form element not provided to getMetaDataFormData.");
        return null;
    }

    // --- 1. Get values from the STATIC fields ---
    // We use .value for text inputs/textareas and .checked for checkboxes.
    const name = formElement.querySelector('#metaDataName').value;
    const description = formElement.querySelector('#metaDataDescription').value;
    const isActive = formElement.querySelector('#metaDataActive').checked;

    // --- 3. Combine everything into a final payload object ---
    // This structure is designed to match your Pydantic "Create" model.
    const formData = {
        "name": name,
        "description": description,
        "isActive": isActive
    };

    return formData;
}

const renderAccordionDetails = (item) => {
    const dateModified = formatDate(item.ModifiedDate);


    return `
    <div class="accordion-body bg-slate-50 p-6" data-id="${item.MetaDataID}">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-12">
            <!-- LEFT COLUMN: Remains the same -->
            <div>
                 <table class="w-full text-sm">
                    <tbody>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500 w-1/3">ID</td><td class="py-2 text-gray-900">${item.MetaDataID}</td></tr>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500">Name</td><td class="py-2 text-gray-900">
                            <span class="view-state view-state-name">${item.Name}</span>
                            <input type="text" value="${item.Name}" class="edit-state edit-state-name hidden w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                        </td></tr>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500">Description</td><td class="py-2 text-gray-900">
                            <span class="view-state view-state-description">${item.Description || ''}</span>
                            <textarea class="edit-state edit-state-description hidden w-full rounded-md border-gray-300 shadow-sm sm:text-sm" rows="3">${item.Description || ''}</textarea>
                        </td></tr>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500">Active</td><td class="py-2 text-gray-900">
                            <span class="view-state view-state-isactive">${item.IsActive ? 'Yes' : 'No'}</span>
                            <div class="edit-state hidden flex items-center">
                                <input type="checkbox" ${item.IsActive ? 'checked' : ''} class="edit-state-isactive h-4 w-4 rounded border-gray-300 text-indigo-600">
                                <label class="ml-2 block text-sm text-gray-900">Is Active</label>
                            </div>
                        </td></tr>
                    </tbody>
                </table>
            </div>

            <!-- RIGHT COLUMN -->
            <div>
                <table class="w-full text-sm mb-4">
                     <tbody>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500">Date Modified</td><td class="py-2 text-gray-900">${dateModified}</td></tr>
                    </tbody>
                </table>
                
            </div>
        </div>
        
        <!-- Action buttons remain the same -->
        <div class="mt-6 text-right">
            <div class="view-state">
                <button class="btn-edit inline-flex justify-center rounded-md border border-gray-300 bg-white py-2 px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50">Edit</button>
            </div>
            <div class="edit-state hidden space-x-2">
                <button class="btn-cancel inline-flex justify-center rounded-md border border-gray-300 bg-white py-2 px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50">Cancel</button>
                <button class="btn-save inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700">Save Changes</button>
            </div>
        </div>
    </div>
    `;
};

/**
* Renders a compact and functional set of pagination controls.
* Includes First, Previous, Next, Last buttons and a page input field.
*/
function renderPagination(containerId, totalItems, itemsPerPage, currentPage) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Pagination container with ID "${containerId}" not found.`);
        return;
    }

    const totalPages = Math.ceil(totalItems / itemsPerPage);
    container.innerHTML = ''; // Clear old controls

    if (totalPages <= 1) {
        return; // No need for pagination.
    }

    // --- Determine button states ---
    const isFirstPage = currentPage === 1;
    const isLastPage = currentPage === totalPages;
    const commonButtonClasses = "px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100";
    const disabledClasses = "opacity-50 cursor-not-allowed";

    // --- Build the HTML string ---
    let paginationHTML = `
        <div class="flex items-center gap-2">
            <!-- First Page Button -->
            <button data-page="1" 
                    class="${commonButtonClasses} ${isFirstPage ? disabledClasses : ''}" 
                    ${isFirstPage ? 'disabled' : ''}>
                First
            </button>
            <!-- Previous Page Button -->
            <button data-page="${currentPage - 1}" 
                    class="${commonButtonClasses} ${isFirstPage ? disabledClasses : ''}" 
                    ${isFirstPage ? 'disabled' : ''}>
                Previous
            </button>
        </div>

        <!-- Page number input and display -->
        <div class="flex items-center gap-2 text-sm text-gray-700">
            <span>Page</span>
            <input type="number" 
                   id="page-input" 
                   class="w-16 text-center border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50" 
                   value="${currentPage}" 
                   min="1" 
                   max="${totalPages}" 
                   aria-label="Current page">
            <span>of ${totalPages}</span>
        </div>

        <div class="flex items-center gap-2">
            <!-- Next Page Button -->
            <button data-page="${currentPage + 1}" 
                    class="${commonButtonClasses} ${isLastPage ? disabledClasses : ''}" 
                    ${isLastPage ? 'disabled' : ''}>
                Next
            </button>
            <!-- Last Page Button -->
            <button data-page="${totalPages}" 
                    class="${commonButtonClasses} ${isLastPage ? disabledClasses : ''}" 
                    ${isLastPage ? 'disabled' : ''}>
                Last
            </button>
        </div>
    `;

    container.innerHTML = paginationHTML;
}

/**
 * Fetches data from the API for a specific page and search term, then updates the UI.
 * This is the central function for all data updates.
 * @param {number} page The page number to fetch.
 * @param {string} searchTerm The search term to filter by.
 */
async function fetchAndRenderPage(tableConfig, page, searchTerm = '') {
    try {
        // --- 1. Call the API with pagination parameters ---
        // NOTE: Your loomeApi.runApiRequest must support passing parameters.
        // This is a hypothetical structure. Adjust it to how your API expects them.
        const apiParams = {
            "page": page,
            "pageSize": rowsPerPage,
            "search": searchTerm
        };
        console.log(apiParams)
        // You might need to pass params differently, e.g., runApiRequest(10, apiParams)
        const response = await window.loomeApi.runApiRequest(API_GET_METADATA, apiParams);

        
        const parsedResponse = safeParseJson(response);
        console.log(parsedResponse)

        // --- 2. Extract Data and Update State ---
        const dataForPage = parsedResponse.Results;
        const totalItems = parsedResponse.RowCount; // The TOTAL count from the server!
        currentPage = parsedResponse.CurrentPage;
        rowsPerPage = parsedResponse.PageSize;
        totalPages = Math.ceil(totalItems / rowsPerPage);
        
        // --- 3. Filter using searchTerm ---
        const lowerCaseSearchTerm = searchTerm.trim().toLowerCase();
        const filteredData = lowerCaseSearchTerm
            ? dataForPage.filter(item => 
                Object.values(item).some(value =>
                    String(value).toLowerCase().includes(lowerCaseSearchTerm)
                )
            )
        : dataForPage;

        // --- 4. Render the UI Components ---
        // Render the table with only the data for the current page
        renderTable(TABLE_CONTAINER_ID, tableConfig, filteredData, {
            renderAccordionContent: renderAccordionDetails 
        });

        // Render pagination using the TOTAL item count from the API
        renderPagination('pagination-controls', totalItems, rowsPerPage, currentPage);

        // Update the total count display
        const metaDataCount = document.getElementById('metaDataCount');
        if(metaDataCount) {
            metaDataCount.textContent = totalItems;
        }

    } catch (error) {
        console.error("Failed to fetch or render page:", error);
        const container = document.getElementById(TABLE_CONTAINER_ID);
        container.innerHTML = `<div class="p-4 text-red-600">Error loading data: ${error.message}</div>`;
    }
}


function renderTable(containerId, tableConfig, data, config = {}) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Container with ID "${containerId}" not found.`);
        return;
    }
    const headers = tableConfig.headers;
    container.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'w-full divide-y divide-gray-200';
    
    // ... (thead creation is the same) ...
    const thead = document.createElement('thead');
    thead.className = 'bg-gray-50';
    const headerRow = document.createElement('tr');
    headers.forEach(headerConfig => {
        const th = document.createElement('th');
        th.scope = 'col';
        let thClasses = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider ';
        if (headerConfig.widthClass) {
            thClasses += headerConfig.widthClass;
        }
        th.className = thClasses;
        th.textContent = headerConfig.label;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);


    const tbody = document.createElement('tbody');
    tbody.className = 'bg-white divide-y divide-gray-200';

    if (data.length === 0) {
        // ... (no data message is the same) ...
        const colSpan = headers.length || 1;
        tbody.innerHTML = `<tr><td colspan="${colSpan}" class="px-6 py-4 text-center text-sm text-gray-500">No data found.</td></tr>`;

    } else {
        data.forEach((item, index) => {
            const isAccordion = typeof config.renderAccordionContent === 'function';
            const triggerRow = document.createElement('tr');
            if (isAccordion) {
                triggerRow.className = 'accordion-trigger hover:bg-gray-50 cursor-pointer';
                // Use a more robust unique ID
                const accordionId = `accordion-content-${item.DataSourceID || index}`;
                triggerRow.dataset.target = `#${accordionId}`;
            }
            
            // ... (main row creation is the same) ...
            headers.forEach(headerConfig => {
                const td = document.createElement('td');
                let tdClasses = 'px-6 py-4 text-sm text-gray-800 ';
                if (headerConfig.className) {
                    tdClasses += headerConfig.className;
                } else {
                    tdClasses += 'whitespace-nowrap';
                }
                td.className = tdClasses;
                let cellContent;
                if (headerConfig.render) {
                    const value = headerConfig.key === 'actions' ? item : item[headerConfig.key];
                    cellContent = headerConfig.render(value);
                } else {
                    const value = item[headerConfig.key];
                    cellContent = value ?? 'N/A';
                }
                if (typeof cellContent === 'string' && cellContent.startsWith('<')) {
                    td.innerHTML = cellContent;
                } else {
                    td.textContent = cellContent;
                }
                triggerRow.appendChild(td);
            });
            tbody.appendChild(triggerRow);

            if (isAccordion) {
                const contentRow = document.createElement('tr');
                const accordionId = `accordion-content-${item.DataSourceID || index}`;
                contentRow.id = accordionId;
                contentRow.className = 'accordion-content hidden';
                
                const contentCell = document.createElement('td');
                contentCell.colSpan = headers.length;
                // The render function is called here with the full item, including 'Fields'
                contentCell.innerHTML = config.renderAccordionContent(item);
                
                contentRow.appendChild(contentCell);
                tbody.appendChild(contentRow);
            }
        });
    }
    table.appendChild(tbody);
    container.appendChild(table);

    // --- SIMPLIFIED Event Listener ---
    if (config.renderAccordionContent) {
        tbody.addEventListener('click', async (event) => {
            const trigger = event.target.closest('.accordion-trigger');
            const accordionBody = event.target.closest('.accordion-body');
            
            // --- Logic for Opening/Closing the Accordion ---
            if (trigger && !accordionBody) {
                event.preventDefault();
                const targetId = trigger.dataset.target;
                const contentRow = document.querySelector(targetId);
                if (contentRow) {
                    contentRow.classList.toggle('hidden');
                    trigger.classList.toggle('expanded');
                    const chevron = trigger.querySelector('.chevron-icon');
                    if (chevron) chevron.classList.toggle('rotate-180');
                }
                return;
            }

            // --- Logic for Edit/Save/Cancel Buttons (remains the same) ---
            const editButton = event.target.closest('.btn-edit');
            const saveButton = event.target.closest('.btn-save');
            const cancelButton = event.target.closest('.btn-cancel');
            
            if (!editButton && !saveButton && !cancelButton) return;
            event.stopPropagation();
            
            const parentAccordion = event.target.closest('.accordion-body');
            const toggleEditState = (isEditing) => {
                parentAccordion.querySelectorAll('.view-state').forEach(el => el.classList.toggle('hidden', isEditing));
                parentAccordion.querySelectorAll('.edit-state').forEach(el => el.classList.toggle('hidden', !isEditing));
            };
            
            if (editButton) toggleEditState(true);

            if (saveButton) {
                // Stop the click from propagating and closing the accordion
                event.stopPropagation();
                
                // Get the button that was clicked and its parent accordion
                const saveBtn = saveButton;
                const accordionBody = saveBtn.closest('.accordion-body');
                const metaDataId = accordionBody.dataset.id; // Using .dataset.id
             
                // Show a "saving..." state for better UX
                saveBtn.textContent = 'Saving...';
                saveBtn.disabled = true;

                try {
                    // --- 1. Gather Data from the Form ---
                    // Use document.querySelector to find elements within the accordionBody
                    const updatedName = accordionBody.querySelector('.edit-state-name').value;
                    const updatedDescription = accordionBody.querySelector('.edit-state-description').value;
                    const updatedIsActive = accordionBody.querySelector('.edit-state-isactive').checked;


                    // --- 2. Send Request to the Endpoint using fetch ---
                    const updateParams = {
                        "meta_data_id": metaDataId ,
                        "description":  updatedDescription,
                        "isActive":  updatedIsActive,
                        "name":  updatedName,
                    };
                    const updatedMetaData = await window.loomeApi.runApiRequest(API_UPDATE_METADATA, updateParams);

                    // --- 3. Handle the Server's Response ---
                    if (!updatedMetaData) {
                        // Handle cases where the API might return an empty or null response on success
                        throw new Error("API call succeeded but returned no data.");
                    }
                    console.log(updatedMetaData)
                    showToast('MetaData edited successfully!\nPlease wait while the data refreshes.', 'success');

                    // --- 4. Update the UI with the New Data ---
                    accordionBody.querySelector('.view-state-name').textContent = updatedMetaData.Name;
                    accordionBody.querySelector('.view-state-description').textContent = updatedMetaData.Description;
                    accordionBody.querySelector('.view-state-isactive').textContent = updatedMetaData.IsActive ? 'Yes' : 'No';


                    // Finally, switch back to view mode by calling your existing function
                    toggleEditState(false);

                    setTimeout(() => {
                        // This code will run AFTER the 3-second delay
                        fetchAndRenderPage(tableConfig, 1, '');
                    }, 3000);

                } catch (error) {
                    console.error('Failed to save:', error);
                    showToast(`Error: ${error.message || 'Failed to save data.'}`, 'error');
                } finally {
                    // Reset the button back to its original state
                    saveBtn.textContent = 'Save Changes';
                    saveBtn.disabled = false;
                }
            }

            if (cancelButton) toggleEditState(false);
        });
    }
}

function formatDate(inputDate) {
    // Log what the function receives
    console.log(`formatDate received:`, inputDate, `(type: ${typeof inputDate})`);

    if (!inputDate) {
        // This will be triggered if inputDate is null, undefined, or an empty string ""
        return 'N/A'; 
    }

    const date = new Date(inputDate);
    
    if (isNaN(date.getTime())) {
        // This will be triggered if the date string is invalid, e.g., "hello world"
        console.warn(`Could not parse invalid date:`, inputDate);
        return 'N/A';
    }
    
    const formattingOptions = {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    };
    
    // The only way this returns undefined is if the function exits before this line.
    return date.toLocaleDateString('en-US', formattingOptions);
}

/**
 * Updates the UI and renders the correct table, optionally filtering the data.
 */
// function updateTable(config, data, tableContainerId, currentPage, rowsPerPage, searchTerm = '') {

//     const lowerCaseSearchTerm = searchTerm.trim().toLowerCase();
//     const filteredData = lowerCaseSearchTerm
//         ? data.filter(item => 
//             Object.values(item).some(value =>
//                 String(value).toLowerCase().includes(lowerCaseSearchTerm)
//             )
//         )
//         : data;

//     // --- 3. PAGINATION LOGIC (NEW!) ---
//     // Calculate the slice of data for the current page
//     const startIndex = (currentPage - 1) * rowsPerPage;
//     const endIndex = startIndex + rowsPerPage;
//     const paginatedData = filteredData.slice(startIndex, endIndex);

//     // --- 4. RENDER TABLE AND PAGINATION ---
//     // Render the table with ONLY the data for the current page
//     renderTable(tableContainerId, config.headers, paginatedData);
    
//     renderPagination('pagination-controls', filteredData.length, rowsPerPage, currentPage);
// }

/**
 * Safely parses a response that might be a JSON string or an object.
 * @param {string | object} response The API response.
 * @returns {object}
 */
function safeParseJson(response) {
    return typeof response === 'string' ? JSON.parse(response) : response;
}


async function renderPlatformAdminMetaDataPage() {
    // --- 1. Define the table configuration ---
    // (Moved outside the try block so it's accessible to fetchAndRenderPage)
    const tableConfig = {
                headers: [
                    { label: "Name", key: "Name", widthClass: "w-4/12" },
                    { label: "Description", key: "Description", className: "break-words", widthClass: "w-6/12" },
                    {
                        label: "Active",
                        key: "IsActive",
                        render: (value) => value == 1 ? 'Yes' : 'No'
                    },
                    { key: 'Details', label: '', widthClass: 'w-12', 
                      render: () => `<div class="flex justify-end"><svg class="chevron-icon h-5 w-5 text-gray-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></div>`
                    }
                ]
    };
        

    // --- 2. Set up Event Listeners ---
    // The search input now calls fetchAndRenderPage
    searchInput.addEventListener('input', () => {
        // When a new search is performed, always go back to page 1
        fetchAndRenderPage(tableConfig, 1, searchInput.value);
    });

    // The pagination container now calls fetchAndRenderPage
    const paginationContainer = document.getElementById('pagination-controls');
    paginationContainer.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-page]');
        if (!button || button.disabled) {
            return;
        }
        const newPage = parseInt(button.dataset.page, 10);
        console.log('newPage')
        console.log(newPage)
        // Fetch the new page, preserving the current search term
        fetchAndRenderPage(tableConfig, newPage, searchInput.value);
    });

    paginationContainer.addEventListener('keydown', (event) => {
        // Only act if the user pressed Enter and the target is our input
        if (event.key === 'Enter' && event.target.id === 'page-input') {
            const inputElement = event.target;
            const newPage = parseInt(inputElement.value, 10);

            // Validate the input
            if (newPage >= 1 && newPage <= totalPages) {
                fetchAndRenderPage(tableConfig, newPage, searchInput.value);
            } else {
                // If invalid, show a message and reset the input to the current page
                alert(`Please enter a page number between 1 and ${totalPages}.`);
                inputElement.value = currentPage; 
            }
        }
    });

    

    const addMetaDataBtn = document.querySelector('#addMetaDataBtn');;
    if (addMetaDataBtn) {
        addMetaDataBtn.addEventListener('click', () => {
            AddMetadata();
        });
    }
    const saveButton = document.getElementById('modal-save-add-metadata-button');
    const handleSaveClick = async () => {
        // Get the modal instance at the time of clicking (not during page load)
        const modalInstance = bootstrap.Modal.getInstance(document.getElementById('addMetaDataModal'));
        
        const form = document.getElementById('addMetaDataForm');
        
        if (!form.checkValidity()) {
            form.classList.add('was-validated');
            console.log("Form is invalid. Aborting save.");
            return;
        }

        const payload = getMetaDataFormData(form);
        console.log("Data gathered from form:", payload);
        
        saveButton.disabled = true;
        saveButton.innerHTML = `
            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
            Saving...
        `;

        try {
            
            const response = await window.loomeApi.runApiRequest(API_ADD_METADATA, payload);
            console.log("RESPONSE: ", response)
            
            showToast('Meta Data created successfully!');
            
            // This should now work!
            modalInstance.hide();
            
            // Optional: Refresh the table to show the new item
            await fetchAndRenderPage(tableConfig, 1, '');
            
        } catch (error) {
            console.error("API call failed:", error);
            showToast(`Error: ${error.message || 'Failed to save data.'}`, 'error');
        } finally {
            saveButton.disabled = false;
            saveButton.innerHTML = 'Save';
        }
    };

    // --- 6. Add the event listener ---
    // This tells the browser: "When a 'click' happens on 'saveButton', run the 'handleSaveClick' function."
    saveButton.addEventListener('click', handleSaveClick);
    

    // --- 3. Initial Page Load ---
    // Make the first call to fetch page 1 with no search term.
    await fetchAndRenderPage(tableConfig, 1, '');
}

// Only run in browser environment, not during Jest testing
if (typeof jest === 'undefined') {
    renderPlatformAdminMetaDataPage();
}

// ============================================================================
// MODULE EXPORTS (for Node.js/Jest testing)
// ============================================================================
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        // Constants
        TABLE_CONTAINER_ID,
        API_GET_METADATA,
        API_ADD_METADATA,
        API_UPDATE_METADATA,
        // Functions
        showToast,
        AddMetadata,
        getMetaDataFormData,
        renderAccordionDetails,
        renderPagination,
        fetchAndRenderPage,
        renderTable,
        formatDate,
        safeParseJson,
        // State accessors for testing
        get currentPage() { return currentPage; },
        set currentPage(val) { currentPage = val; },
        get rowsPerPage() { return rowsPerPage; },
        set rowsPerPage(val) { rowsPerPage = val; }
    };
}

// ============================================================================
// UNIT TESTS
// ============================================================================
if (typeof describe === 'function') {
    const mod = typeof module !== 'undefined' && module.exports ? module.exports : {};

    describe('metaDataPlatformAdmin.js', () => {
        let mockApiResponse;
        let originalLoomeApi;

        beforeEach(() => {
            // Reset state
            mod.currentPage = 1;
            mod.rowsPerPage = 5;

            // Set global totalPages (used in fetchAndRenderPage without declaration)
            global.totalPages = 1;

            // Setup DOM
            document.body.innerHTML = `
                <div id="requests-table-area"></div>
                <div id="pagination-controls"></div>
                <div id="metaDataCount"></div>
                <input id="searchRequests" type="text" />
                <div id="addMetaDataModalBody"></div>
                <div id="addMetaDataModal" class="modal"></div>
                <button id="addMetaDataBtn"></button>
                <button id="modal-save-add-metadata-button">Save</button>
                <form id="addMetaDataForm">
                    <input id="metaDataName" value="Test Meta" />
                    <textarea id="metaDataDescription">Test Description</textarea>
                    <input type="checkbox" id="metaDataActive" checked />
                </form>
            `;

            // Mock console methods
            jest.spyOn(console, 'log').mockImplementation(() => {});
            jest.spyOn(console, 'warn').mockImplementation(() => {});
            jest.spyOn(console, 'error').mockImplementation(() => {});

            // Store original API and setup mock
            originalLoomeApi = window.loomeApi;
            mockApiResponse = null;
            window.loomeApi = {
                runApiRequest: jest.fn((apiId, params) => Promise.resolve(mockApiResponse))
            };
        });

        afterEach(() => {
            window.loomeApi = originalLoomeApi;
            jest.restoreAllMocks();
        });

        // =====================================================================
        // Constants Tests
        // =====================================================================
        describe('Constants', () => {
            test('TABLE_CONTAINER_ID should be requests-table-area', () => {
                expect(mod.TABLE_CONTAINER_ID).toBe('requests-table-area');
            });

            test('API_GET_METADATA should be GetMetadata', () => {
                expect(mod.API_GET_METADATA).toBe('GetMetadata');
            });

            test('API_ADD_METADATA should be AddMetaData', () => {
                expect(mod.API_ADD_METADATA).toBe('AddMetaData');
            });

            test('API_UPDATE_METADATA should be UpdateMetaData', () => {
                expect(mod.API_UPDATE_METADATA).toBe('UpdateMetaData');
            });
        });

        // =====================================================================
        // safeParseJson Tests
        // =====================================================================
        describe('safeParseJson', () => {
            test('should parse JSON string to object', () => {
                const jsonString = '{"name":"test","value":123}';
                const result = mod.safeParseJson(jsonString);
                expect(result).toEqual({ name: 'test', value: 123 });
            });

            test('should return object as-is if already an object', () => {
                const obj = { name: 'test', value: 123 };
                const result = mod.safeParseJson(obj);
                expect(result).toBe(obj);
            });

            test('should parse JSON array string', () => {
                const jsonString = '[{"id":1},{"id":2}]';
                const result = mod.safeParseJson(jsonString);
                expect(result).toEqual([{ id: 1 }, { id: 2 }]);
            });

            test('should return array as-is if already an array', () => {
                const arr = [{ id: 1 }, { id: 2 }];
                const result = mod.safeParseJson(arr);
                expect(result).toBe(arr);
            });

            test('should handle paginated response string', () => {
                const paginatedStr = '{"Results":[{"MetaDataID":1}],"CurrentPage":1,"PageCount":3,"RowCount":25}';
                const result = mod.safeParseJson(paginatedStr);
                expect(result.Results).toEqual([{ MetaDataID: 1 }]);
                expect(result.PageCount).toBe(3);
                expect(result.RowCount).toBe(25);
            });

            test('should handle empty object string', () => {
                const result = mod.safeParseJson('{}');
                expect(result).toEqual({});
            });
        });

        // =====================================================================
        // showToast Tests
        // =====================================================================
        describe('showToast', () => {
            beforeEach(() => {
                jest.useFakeTimers();
            });

            afterEach(() => {
                jest.useRealTimers();
            });

            test('should create a toast element with success class by default', () => {
                mod.showToast('Test message');
                const toast = document.querySelector('.toast-notification');
                expect(toast).toBeTruthy();
                expect(toast.classList.contains('toast-success')).toBe(true);
                expect(toast.textContent).toBe('Test message');
            });

            test('should create a toast element with error class when type is error', () => {
                mod.showToast('Error message', 'error');
                const toast = document.querySelector('.toast-notification');
                expect(toast).toBeTruthy();
                expect(toast.classList.contains('toast-error')).toBe(true);
            });

            test('should create a toast element with info class when type is info', () => {
                mod.showToast('Info message', 'info');
                const toast = document.querySelector('.toast-notification');
                expect(toast.classList.contains('toast-info')).toBe(true);
            });

            test('should apply fade-in animation after short delay', () => {
                mod.showToast('Animated message');
                jest.advanceTimersByTime(15);
                const toast = document.querySelector('.toast-notification');
                expect(toast.style.opacity).toBe('1');
                expect(toast.style.transform).toBe('translateY(0)');
            });

            test('should start fade-out after duration', () => {
                mod.showToast('Timed message', 'success', 3000);
                jest.advanceTimersByTime(3015);
                const toast = document.querySelector('.toast-notification');
                expect(toast.style.opacity).toBe('0');
            });

            test('should use custom duration', () => {
                mod.showToast('Custom duration', 'success', 5000);
                jest.advanceTimersByTime(3000);
                const toast = document.querySelector('.toast-notification');
                expect(toast.style.opacity).toBe('1'); // Still visible
                jest.advanceTimersByTime(2100);
                expect(toast.style.opacity).toBe('0'); // Now fading
            });
        });

        // =====================================================================
        // formatDate Tests
        // =====================================================================
        describe('formatDate', () => {
            test('should format valid date string', () => {
                const result = mod.formatDate('2024-06-15T10:30:00');
                expect(result).toBe('June 15, 2024');
            });

            test('should format ISO date string', () => {
                const result = mod.formatDate('2023-12-25');
                expect(result).toBe('December 25, 2023');
            });

            test('should return N/A for null input', () => {
                const result = mod.formatDate(null);
                expect(result).toBe('N/A');
            });

            test('should return N/A for undefined input', () => {
                const result = mod.formatDate(undefined);
                expect(result).toBe('N/A');
            });

            test('should return N/A for empty string', () => {
                const result = mod.formatDate('');
                expect(result).toBe('N/A');
            });

            test('should return N/A for invalid date string', () => {
                const result = mod.formatDate('not-a-date');
                expect(result).toBe('N/A');
            });

            test('should handle Date object', () => {
                const date = new Date('2024-01-01');
                const result = mod.formatDate(date);
                expect(result).toBe('January 1, 2024');
            });
        });

        // =====================================================================
        // AddMetadata Tests
        // =====================================================================
        describe('AddMetadata', () => {
            test('should populate modal body with form HTML', () => {
                mod.AddMetadata();
                const modalBody = document.getElementById('addMetaDataModalBody');
                expect(modalBody.innerHTML).toContain('addMetaDataForm');
                expect(modalBody.innerHTML).toContain('metaDataName');
                expect(modalBody.innerHTML).toContain('metaDataDescription');
                expect(modalBody.innerHTML).toContain('metaDataActive');
            });

            test('should include Name field', () => {
                mod.AddMetadata();
                const modalBody = document.getElementById('addMetaDataModalBody');
                expect(modalBody.innerHTML).toContain('Name');
                expect(modalBody.querySelector('#metaDataName')).toBeTruthy();
            });

            test('should include Description field', () => {
                mod.AddMetadata();
                const modalBody = document.getElementById('addMetaDataModalBody');
                expect(modalBody.innerHTML).toContain('Description');
                expect(modalBody.querySelector('#metaDataDescription')).toBeTruthy();
            });

            test('should include Active checkbox', () => {
                mod.AddMetadata();
                const modalBody = document.getElementById('addMetaDataModalBody');
                expect(modalBody.innerHTML).toContain('Active');
                const checkbox = modalBody.querySelector('#metaDataActive');
                expect(checkbox).toBeTruthy();
                expect(checkbox.type).toBe('checkbox');
            });

            test('should have Active checkbox checked by default', () => {
                mod.AddMetadata();
                const modalBody = document.getElementById('addMetaDataModalBody');
                const checkbox = modalBody.querySelector('#metaDataActive');
                expect(checkbox.checked).toBe(true);
            });
        });

        // =====================================================================
        // getMetaDataFormData Tests
        // =====================================================================
        describe('getMetaDataFormData', () => {
            test('should return null if form element is not provided', () => {
                const result = mod.getMetaDataFormData(null);
                expect(result).toBeNull();
            });

            test('should gather form data correctly', () => {
                const form = document.getElementById('addMetaDataForm');
                form.querySelector('#metaDataName').value = 'Test Name';
                form.querySelector('#metaDataDescription').value = 'Test Desc';
                form.querySelector('#metaDataActive').checked = true;

                const result = mod.getMetaDataFormData(form);
                expect(result).toEqual({
                    name: 'Test Name',
                    description: 'Test Desc',
                    isActive: true
                });
            });

            test('should handle unchecked Active checkbox', () => {
                const form = document.getElementById('addMetaDataForm');
                form.querySelector('#metaDataActive').checked = false;

                const result = mod.getMetaDataFormData(form);
                expect(result.isActive).toBe(false);
            });

            test('should handle empty fields', () => {
                const form = document.getElementById('addMetaDataForm');
                form.querySelector('#metaDataName').value = '';
                form.querySelector('#metaDataDescription').value = '';

                const result = mod.getMetaDataFormData(form);
                expect(result.name).toBe('');
                expect(result.description).toBe('');
            });

            test('should preserve whitespace in text fields', () => {
                const form = document.getElementById('addMetaDataForm');
                form.querySelector('#metaDataName').value = '  Spaced Name  ';
                form.querySelector('#metaDataDescription').value = 'Line1\nLine2';

                const result = mod.getMetaDataFormData(form);
                expect(result.name).toBe('  Spaced Name  ');
                expect(result.description).toBe('Line1\nLine2');
            });
        });

        // =====================================================================
        // renderAccordionDetails Tests
        // =====================================================================
        describe('renderAccordionDetails', () => {
            test('should render accordion body with data-id attribute', () => {
                const item = {
                    MetaDataID: 123,
                    Name: 'Test Meta',
                    Description: 'Test Description',
                    IsActive: true,
                    ModifiedDate: '2024-06-15T10:30:00'
                };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('data-id="123"');
            });

            test('should render MetaDataID', () => {
                const item = { MetaDataID: 456, Name: 'Test', IsActive: true };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('456');
            });

            test('should render Name with view and edit states', () => {
                const item = { MetaDataID: 1, Name: 'My Meta', IsActive: true };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('view-state-name');
                expect(result).toContain('edit-state-name');
                expect(result).toContain('My Meta');
            });

            test('should render Description with view and edit states', () => {
                const item = { MetaDataID: 1, Name: 'Test', Description: 'My Description', IsActive: true };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('view-state-description');
                expect(result).toContain('edit-state-description');
                expect(result).toContain('My Description');
            });

            test('should render IsActive as Yes when true', () => {
                const item = { MetaDataID: 1, Name: 'Test', IsActive: true };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('view-state-isactive');
                expect(result).toMatch(/<span class="view-state view-state-isactive">Yes<\/span>/);
            });

            test('should render IsActive as No when false', () => {
                const item = { MetaDataID: 1, Name: 'Test', IsActive: false };
                const result = mod.renderAccordionDetails(item);
                expect(result).toMatch(/<span class="view-state view-state-isactive">No<\/span>/);
            });

            test('should render checkbox checked when IsActive is true', () => {
                const item = { MetaDataID: 1, Name: 'Test', IsActive: true };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('checked');
            });

            test('should render checkbox unchecked when IsActive is false', () => {
                const item = { MetaDataID: 1, Name: 'Test', IsActive: false };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('edit-state-isactive');
                // The checkbox should not have 'checked' attribute
                expect(result).toMatch(/<input type="checkbox"\s+class="edit-state-isactive/);
            });

            test('should render Edit button', () => {
                const item = { MetaDataID: 1, Name: 'Test', IsActive: true };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('btn-edit');
                expect(result).toContain('Edit');
            });

            test('should render Save and Cancel buttons', () => {
                const item = { MetaDataID: 1, Name: 'Test', IsActive: true };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('btn-save');
                expect(result).toContain('btn-cancel');
                expect(result).toContain('Save Changes');
                expect(result).toContain('Cancel');
            });

            test('should render formatted date', () => {
                const item = { MetaDataID: 1, Name: 'Test', IsActive: true, ModifiedDate: '2024-06-15' };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('June 15, 2024');
            });

            test('should handle empty description', () => {
                const item = { MetaDataID: 1, Name: 'Test', Description: null, IsActive: true };
                const result = mod.renderAccordionDetails(item);
                expect(result).toContain('view-state-description');
            });
        });

        // =====================================================================
        // renderPagination Tests
        // =====================================================================
        describe('renderPagination', () => {
            test('should render pagination controls correctly', () => {
                mod.renderPagination('pagination-controls', 50, 5, 1);
                const container = document.getElementById('pagination-controls');
                expect(container.innerHTML).toContain('First');
                expect(container.innerHTML).toContain('Previous');
                expect(container.innerHTML).toContain('Next');
                expect(container.innerHTML).toContain('Last');
            });

            test('should show correct total pages', () => {
                mod.renderPagination('pagination-controls', 50, 5, 1);
                const container = document.getElementById('pagination-controls');
                expect(container.innerHTML).toContain('of 10');
            });

            test('should disable First and Previous buttons on first page', () => {
                mod.renderPagination('pagination-controls', 50, 5, 1);
                const buttons = document.querySelectorAll('button[data-page]');
                const firstBtn = buttons[0];
                const prevBtn = buttons[1];
                expect(firstBtn.disabled).toBe(true);
                expect(prevBtn.disabled).toBe(true);
            });

            test('should disable Next and Last buttons on last page', () => {
                mod.renderPagination('pagination-controls', 50, 5, 10);
                const buttons = document.querySelectorAll('button[data-page]');
                const nextBtn = buttons[2];
                const lastBtn = buttons[3];
                expect(nextBtn.disabled).toBe(true);
                expect(lastBtn.disabled).toBe(true);
            });

            test('should not render pagination for single page', () => {
                mod.renderPagination('pagination-controls', 3, 5, 1);
                const container = document.getElementById('pagination-controls');
                expect(container.innerHTML).toBe('');
            });

            test('should set correct value in page input', () => {
                mod.renderPagination('pagination-controls', 50, 5, 3);
                const input = document.getElementById('page-input');
                expect(input.value).toBe('3');
            });

            test('should set correct min and max on page input', () => {
                mod.renderPagination('pagination-controls', 50, 5, 3);
                const input = document.getElementById('page-input');
                expect(input.min).toBe('1');
                expect(input.max).toBe('10');
            });

            test('should handle empty container gracefully', () => {
                expect(() => mod.renderPagination('nonexistent', 50, 5, 1)).not.toThrow();
            });

            test('should enable all buttons on middle page', () => {
                mod.renderPagination('pagination-controls', 50, 5, 5);
                const buttons = document.querySelectorAll('button[data-page]');
                buttons.forEach(btn => {
                    expect(btn.disabled).toBe(false);
                });
            });

            test('should clear previous pagination content', () => {
                const container = document.getElementById('pagination-controls');
                container.innerHTML = '<div>Old Content</div>';
                mod.renderPagination('pagination-controls', 50, 5, 1);
                expect(container.innerHTML).not.toContain('Old Content');
            });
        });

        // =====================================================================
        // renderTable Tests
        // =====================================================================
        describe('renderTable', () => {
            const tableConfig = {
                headers: [
                    { label: 'Name', key: 'Name' },
                    { label: 'Description', key: 'Description' },
                    { label: 'Active', key: 'IsActive', render: (val) => val ? 'Yes' : 'No' }
                ]
            };

            test('should render table with headers', () => {
                mod.renderTable('requests-table-area', tableConfig, []);
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Name');
                expect(container.innerHTML).toContain('Description');
                expect(container.innerHTML).toContain('Active');
            });

            test('should render table rows with data', () => {
                const data = [
                    { Name: 'Meta 1', Description: 'Desc 1', IsActive: true },
                    { Name: 'Meta 2', Description: 'Desc 2', IsActive: false }
                ];
                mod.renderTable('requests-table-area', tableConfig, data);
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Meta 1');
                expect(container.innerHTML).toContain('Meta 2');
            });

            test('should render custom render functions', () => {
                const data = [{ Name: 'Test', Description: 'Desc', IsActive: true }];
                mod.renderTable('requests-table-area', tableConfig, data);
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Yes');
            });

            test('should show no data message when data is empty', () => {
                mod.renderTable('requests-table-area', tableConfig, []);
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('No data found');
            });

            test('should handle N/A for missing values', () => {
                const data = [{ Name: 'Test' }]; // Missing Description and IsActive
                mod.renderTable('requests-table-area', tableConfig, data);
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('N/A');
            });

            test('should handle empty container gracefully', () => {
                expect(() => mod.renderTable('nonexistent', tableConfig, [])).not.toThrow();
            });

            test('should apply width classes to headers', () => {
                const configWithWidths = {
                    headers: [
                        { label: 'Name', key: 'Name', widthClass: 'w-4/12' },
                        { label: 'Active', key: 'IsActive' }
                    ]
                };
                mod.renderTable('requests-table-area', configWithWidths, []);
                const th = document.querySelector('th');
                expect(th.className).toContain('w-4/12');
            });

            test('should render accordion content when config provided', () => {
                const data = [{ MetaDataID: 1, Name: 'Test', IsActive: true }];
                mod.renderTable('requests-table-area', tableConfig, data, {
                    renderAccordionContent: (item) => `<div class="test-accordion">${item.Name}</div>`
                });
                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('accordion-content');
                expect(container.innerHTML).toContain('test-accordion');
            });

            test('should add accordion-trigger class when accordion config provided', () => {
                const data = [{ MetaDataID: 1, Name: 'Test', IsActive: true }];
                mod.renderTable('requests-table-area', tableConfig, data, {
                    renderAccordionContent: () => '<div>Accordion</div>'
                });
                const trigger = document.querySelector('.accordion-trigger');
                expect(trigger).toBeTruthy();
            });
        });

        // =====================================================================
        // fetchAndRenderPage Tests
        // =====================================================================
        describe('fetchAndRenderPage', () => {
            const tableConfig = {
                headers: [
                    { label: 'Name', key: 'Name' },
                    { label: 'Active', key: 'IsActive' }
                ]
            };

            test('should call API with correct parameters', async () => {
                mockApiResponse = JSON.stringify({
                    Results: [],
                    RowCount: 0,
                    CurrentPage: 1,
                    PageSize: 5,
                    PageCount: 0
                });

                await mod.fetchAndRenderPage(tableConfig, 2, 'search');

                expect(window.loomeApi.runApiRequest).toHaveBeenCalledWith(
                    'GetMetadata',
                    expect.objectContaining({
                        page: 2,
                        pageSize: 5,
                        search: 'search'
                    })
                );
            });

            test('should render table with fetched data', async () => {
                mockApiResponse = JSON.stringify({
                    Results: [
                        { MetaDataID: 1, Name: 'Test Meta', IsActive: true }
                    ],
                    RowCount: 1,
                    CurrentPage: 1,
                    PageSize: 5,
                    PageCount: 1
                });

                await mod.fetchAndRenderPage(tableConfig, 1, '');

                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Test Meta');
            });

            test('should update metaDataCount element', async () => {
                mockApiResponse = JSON.stringify({
                    Results: [],
                    RowCount: 42,
                    CurrentPage: 1,
                    PageSize: 5,
                    PageCount: 9
                });

                await mod.fetchAndRenderPage(tableConfig, 1, '');

                const countEl = document.getElementById('metaDataCount');
                expect(countEl.textContent).toBe('42');
            });

            test('should handle API errors gracefully', async () => {
                window.loomeApi.runApiRequest = jest.fn(() => Promise.reject(new Error('API Error')));

                await mod.fetchAndRenderPage(tableConfig, 1, '');

                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Error loading data');
            });

            test('should filter data by search term', async () => {
                mockApiResponse = JSON.stringify({
                    Results: [
                        { MetaDataID: 1, Name: 'Apple', IsActive: true },
                        { MetaDataID: 2, Name: 'Banana', IsActive: true }
                    ],
                    RowCount: 2,
                    CurrentPage: 1,
                    PageSize: 5,
                    PageCount: 1
                });

                await mod.fetchAndRenderPage(tableConfig, 1, 'apple');

                const container = document.getElementById('requests-table-area');
                expect(container.innerHTML).toContain('Apple');
            });

            test('should update currentPage from response', async () => {
                mockApiResponse = JSON.stringify({
                    Results: [],
                    RowCount: 50,
                    CurrentPage: 3,
                    PageSize: 5,
                    PageCount: 10
                });

                await mod.fetchAndRenderPage(tableConfig, 3, '');

                expect(mod.currentPage).toBe(3);
            });

            test('should update rowsPerPage from response', async () => {
                mockApiResponse = JSON.stringify({
                    Results: [],
                    RowCount: 50,
                    CurrentPage: 1,
                    PageSize: 10,
                    PageCount: 5
                });

                await mod.fetchAndRenderPage(tableConfig, 1, '');

                expect(mod.rowsPerPage).toBe(10);
            });
        });

        // =====================================================================
        // State Management Tests
        // =====================================================================
        describe('State Management', () => {
            test('should allow setting and getting currentPage', () => {
                mod.currentPage = 5;
                expect(mod.currentPage).toBe(5);
            });

            test('should allow setting and getting rowsPerPage', () => {
                mod.rowsPerPage = 10;
                expect(mod.rowsPerPage).toBe(10);
            });

            test('currentPage should default to 1', () => {
                mod.currentPage = 1;
                expect(mod.currentPage).toBe(1);
            });

            test('rowsPerPage should be updatable', () => {
                mod.rowsPerPage = 20;
                expect(mod.rowsPerPage).toBe(20);
                mod.rowsPerPage = 5;
                expect(mod.rowsPerPage).toBe(5);
            });
        });

        // =====================================================================
        // Integration Tests
        // =====================================================================
        describe('Integration Tests', () => {
            test('should render full metadata table with accordion', async () => {
                const tableConfig = {
                    headers: [
                        { label: 'Name', key: 'Name' },
                        { label: 'Description', key: 'Description' },
                        { label: 'Active', key: 'IsActive', render: (val) => val ? 'Yes' : 'No' }
                    ]
                };

                mockApiResponse = JSON.stringify({
                    Results: [
                        {
                            MetaDataID: 1,
                            Name: 'Integration Test',
                            Description: 'Test Description',
                            IsActive: true,
                            ModifiedDate: '2024-06-15T10:30:00'
                        }
                    ],
                    RowCount: 1,
                    CurrentPage: 1,
                    PageSize: 5,
                    PageCount: 1
                });

                await mod.fetchAndRenderPage(tableConfig, 1, '');

                const container = document.getElementById('requests-table-area');
                expect(container.querySelector('table')).toBeTruthy();
                expect(container.innerHTML).toContain('Integration Test');
            });

            test('should handle form submission flow', () => {
                // Setup form with AddMetadata
                mod.AddMetadata();
                
                // Fill form
                const form = document.getElementById('addMetaDataForm');
                form.querySelector('#metaDataName').value = 'New Meta';
                form.querySelector('#metaDataDescription').value = 'New Description';
                form.querySelector('#metaDataActive').checked = true;

                // Gather data
                const data = mod.getMetaDataFormData(form);

                expect(data).toEqual({
                    name: 'New Meta',
                    description: 'New Description',
                    isActive: true
                });
            });
        });

    }); // End describe('metaDataPlatformAdmin.js')
} // End if (typeof describe === 'function')

