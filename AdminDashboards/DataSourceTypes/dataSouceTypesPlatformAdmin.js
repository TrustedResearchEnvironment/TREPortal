// Generated by Copilot
// Define the single container ID for the table
const TABLE_CONTAINER_ID = 'requests-table-area';
const API_DATASRCTYPES_ID = 'GetDataSourceTypes';
const API_ADD_METADATA = 'AddMetaData';
const API_UPDATE_METADATA = 'UpdateMetaData';

// --- STATE MANAGEMENT ---
// These variables need to be accessible by multiple functions.
let currentPage = 1;
let rowsPerPage = 5; // Default, will be updated by API response
let tableConfig = {}; // Will hold your headers configuration
const searchInput = document.getElementById('searchRequests');


function AddDataSrcType() {
    // Get the modal's body element
    const modalBody = document.getElementById('addDataSrcTypeModalBody');
    console.log("IN add datasrctype")

    // Populate the modal body with the provided HTML content (your markup)
    modalBody.innerHTML = `
                <form id="addDataSrcTypeForm">
                        <!-- Name Field -->
                        <div class="mb-3">
                            <label for="Name" class="form-label">Name</label>
                            <input id="dataSrcTypeName" placeholder="Name for this Meta Data" class="form-control">
                        </div>

                        <!-- Description Field -->
                        <div class="mb-3">
                            <label for="Description" class="form-label">Description</label>
                            <textarea rows="2" id="dataSrcTypeDescription" placeholder="Description of this Meta Data" class="form-control"></textarea>
                        </div>

                        <!-- Active Checkbox -->
                        <div class="mb-3 form-check">
                            <input type="checkbox" id="dataSrcTypeActive" class="form-check-input" checked>
                            <label class="form-check-label" for="dataSrcTypeActive">Active</label>
                        </div>

                    </form>
            
    `;
    
}

/**
 * Gathers all data from the "Add Data Source" modal form.
 * It handles both static fields and dynamically generated fields.
 *
 * @param {HTMLElement} formElement - The <form> element to read data from.
 * @returns {object | null} An object containing the structured form data, or null if the form is not found.
 */
function getDataSrcTypeFormData(formElement) {
    if (!formElement) {
        console.error("Form element not provided to getDataSrcTypeFormData.");
        return null;
    }

    // --- 1. Get values from the STATIC fields ---
    // We use .value for text inputs/textareas and .checked for checkboxes.
    const name = formElement.querySelector('#dataSrcTypeName').value;
    const description = formElement.querySelector('#dataSrcTypeDescription').value;
    const isActive = formElement.querySelector('#dataSrcTypeActive').checked;

    // --- 3. Combine everything into a final payload object ---
    // This structure is designed to match your Pydantic "Create" model.
    const formData = {
        "name": name,
        "description": description,
        "isActive": isActive
    };

    return formData;
}

const renderAccordionDetails = (item) => {
    const dateModified = formatDate(item.ModifiedDate);


    return `
    <div class="accordion-body bg-slate-50 p-6" data-id="${item.DataSourceTypeID}">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-12">
            <!-- LEFT COLUMN: Remains the same -->
            <div>
                 <table class="w-full text-sm">
                    <tbody>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500 w-1/3">ID</td><td class="py-2 text-gray-900">${item.DataSourceTypeID}</td></tr>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500">Name</td><td class="py-2 text-gray-900">
                            <span class="view-state view-state-name">${item.Name}</span>
                            <input type="text" value="${item.Name}" class="edit-state edit-state-name hidden w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                        </td></tr>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500">Description</td><td class="py-2 text-gray-900">
                            <span class="view-state view-state-description">${item.Description || ''}</span>
                            <textarea class="edit-state edit-state-description hidden w-full rounded-md border-gray-300 shadow-sm sm:text-sm" rows="3">${item.Description || ''}</textarea>
                        </td></tr>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500">Active</td><td class="py-2 text-gray-900">
                            <span class="view-state view-state-isactive">${item.IsActive ? 'Yes' : 'No'}</span>
                            <div class="edit-state hidden flex items-center">
                                <input type="checkbox" ${item.IsActive ? 'checked' : ''} class="edit-state-isactive h-4 w-4 rounded border-gray-300 text-indigo-600">
                                <label class="ml-2 block text-sm text-gray-900">Is Active</label>
                            </div>
                        </td></tr>
                    </tbody>
                </table>
            </div>

            <!-- RIGHT COLUMN -->
            <div>
                <table class="w-full text-sm mb-4">
                     <tbody>
                        <tr class="border-b"><td class="py-2 font-medium text-gray-500">Date Modified</td><td class="py-2 text-gray-900">${dateModified}</td></tr>
                    </tbody>
                </table>
                
            </div>
        </div>
        
        <!-- ACTION BUTTONS -->
    </div>
    `;
};


/**
 * Renders pagination controls.
 * (This function NO LONGER adds event listeners).
 */
function renderPagination(containerId, totalItems, itemsPerPage, currentPage) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const totalPages = Math.ceil(totalItems / itemsPerPage);
    container.innerHTML = ''; // Clear old controls

    if (totalPages <= 1) {
        return; // No need for pagination.
    }

    // --- Previous Button ---
    const prevDisabled = currentPage === 1;
    let paginationHTML = `
        <button data-page="${currentPage - 1}" class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100 ${prevDisabled ? 'opacity-50 cursor-not-allowed' : ''}" ${prevDisabled ? 'disabled' : ''}>
            Previous
        </button>
    `;

    // --- Page Number Buttons ---
    paginationHTML += '<div class="flex items-center gap-2">';
    for (let i = 1; i <= totalPages; i++) {
        const isActive = i === currentPage;
        paginationHTML += `
            <button data-page="${i}" class="px-4 py-2 text-sm font-medium ${isActive ? 'text-white bg-blue-600' : 'text-gray-700 bg-white'} border border-gray-300 rounded-lg hover:bg-gray-100">
                ${i}
            </button>
        `;
    }
    paginationHTML += '</div>';

    // --- Next Button ---
    const nextDisabled = currentPage === totalPages;
    paginationHTML += `
        <button data-page="${currentPage + 1}" class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100 ${nextDisabled ? 'opacity-50 cursor-not-allowed' : ''}" ${nextDisabled ? 'disabled' : ''}>
            Next
        </button>
    `;

    container.innerHTML = paginationHTML;
}

/**
 * Fetches data from the API for a specific page and search term, then updates the UI.
 * This is the central function for all data updates.
 * @param {number} page The page number to fetch.
 * @param {string} searchTerm The search term to filter by.
 */
async function fetchAndRenderPage(page, searchTerm = '') {
    try {
        // --- 1. Call the API with pagination parameters ---
        // NOTE: Your loomeApi.runApiRequest must support passing parameters.
        // This is a hypothetical structure. Adjust it to how your API expects them.
        const apiParams = {
            "page": page,
            "pageSize": rowsPerPage,
            "search": searchTerm
        };
        console.log(apiParams)
        // You might need to pass params differently, e.g., runApiRequest(10, apiParams)
        const response = await window.loomeApi.runApiRequest(API_DATASRCTYPES_ID, apiParams);

        
        const parsedResponse = safeParseJson(response);
        console.log(parsedResponse)

        // --- 2. Extract Data and Update State ---
        const dataForPage = parsedResponse.Results;
        const totalItems = parsedResponse.RowCount; // The TOTAL count from the server!
        currentPage = parsedResponse.CurrentPage;
        rowsPerPage = parsedResponse.PageSize;
        totalPages = Math.ceil(totalItems / rowsPerPage);
        
        // --- 3. Filter using searchTerm ---
        const lowerCaseSearchTerm = searchTerm.trim().toLowerCase();
        const filteredData = lowerCaseSearchTerm
            ? dataForPage.filter(item => 
                Object.values(item).some(value =>
                    String(value).toLowerCase().includes(lowerCaseSearchTerm)
                )
            )
        : dataForPage;

        // --- 4. Render the UI Components ---
        // Render the table with only the data for the current page
        console.log("before renderTable headers: ",tableConfig.headers)
        renderTable(TABLE_CONTAINER_ID, tableConfig.headers, filteredData);
        // renderTable(TABLE_CONTAINER_ID, tableConfig.headers, filteredData, {
        //     renderAccordionContent: renderAccordionDetails 
        // });

        // Render pagination using the TOTAL item count from the API
        renderPagination('pagination-controls', totalItems, rowsPerPage, currentPage);

        // Update the total count display
        const dataSourceCount = document.getElementById('dataSourceTypesCount');
        if(dataSourceCount) {
            dataSourceCount.textContent = totalItems;
        }

    } catch (error) {
        console.error("Failed to fetch or render page:", error);
        const container = document.getElementById(TABLE_CONTAINER_ID);
        container.innerHTML = `<div class="p-4 text-red-600">Error loading data: ${error.message}</div>`;
    }
}

/**
 * Renders a generic data table based on a configuration object.
 * @param {string} containerId - The ID of the element to render the table into.
 * @param {Array} headers - The array of header configuration objects.
 * @param {Array} data - The array of data objects to display.
//  */
function renderTable(containerId, headers, data, config = {}) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Container with ID "${containerId}" not found.`);
        return;
    }
    container.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'w-full divide-y divide-gray-200';
    
    // ... (thead creation is the same) ...
    const thead = document.createElement('thead');
    thead.className = 'bg-gray-50';
    const headerRow = document.createElement('tr');
    console.log("headers forEach: ",headers)
    headers.forEach(headerConfig => {
        const th = document.createElement('th');
        th.scope = 'col';
        let thClasses = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider ';
        if (headerConfig.widthClass) {
            thClasses += headerConfig.widthClass;
        }
        th.className = thClasses;
        th.textContent = headerConfig.label;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);


    const tbody = document.createElement('tbody');
    tbody.className = 'bg-white divide-y divide-gray-200';

    console.log("data forEach: ",data)
    if (data.length === 0) {
        // ... (no data message is the same) ...
        const colSpan = headers.length || 1;
        tbody.innerHTML = `<tr><td colspan="${colSpan}" class="px-6 py-4 text-center text-sm text-gray-500">No data found.</td></tr>`;

    } else {
        data.forEach((item, index) => {
            const triggerRow = document.createElement('tr');

            headers.forEach(headerConfig => {
                const td = document.createElement('td');
                let tdClasses = 'px-6 py-4 text-sm text-gray-800 ';
                if (headerConfig.className) {
                    tdClasses += headerConfig.className;
                } else {
                    tdClasses += 'whitespace-nowrap';
                }
                td.className = tdClasses;
                let cellContent;
                if (headerConfig.render) {
                    const value = headerConfig.key === 'actions' ? item : item[headerConfig.key];
                    cellContent = headerConfig.render(value);
                } else {
                    const value = item[headerConfig.key];
                    cellContent = value ?? 'N/A';
                }
                if (typeof cellContent === 'string' && cellContent.startsWith('<')) {
                    td.innerHTML = cellContent;
                } else {
                    td.textContent = cellContent;
                }
                triggerRow.appendChild(td);
            });
            tbody.appendChild(triggerRow);
        });
    }
    table.appendChild(tbody);
    container.appendChild(table);

}

function formatDate(inputDate) {
    // Log what the function receives
    console.log(`formatDate received:`, inputDate, `(type: ${typeof inputDate})`);

    if (!inputDate) {
        // This will be triggered if inputDate is null, undefined, or an empty string ""
        return 'N/A'; 
    }

    const date = new Date(inputDate);
    
    if (isNaN(date.getTime())) {
        // This will be triggered if the date string is invalid, e.g., "hello world"
        console.warn(`Could not parse invalid date:`, inputDate);
        return 'N/A';
    }
    
    const formattingOptions = {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    };
    
    // The only way this returns undefined is if the function exits before this line.
    return date.toLocaleDateString('en-US', formattingOptions);
}

/**
 * Updates the UI and renders the correct table, optionally filtering the data.
 */
function updateTable(config, data, tableContainerId, currentPage, rowsPerPage, searchTerm = '') {

    const lowerCaseSearchTerm = searchTerm.trim().toLowerCase();
    const filteredData = lowerCaseSearchTerm
        ? data.filter(item => 
            Object.values(item).some(value =>
                String(value).toLowerCase().includes(lowerCaseSearchTerm)
            )
        )
        : data;

    // --- 3. PAGINATION LOGIC (NEW!) ---
    // Calculate the slice of data for the current page
    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    const paginatedData = filteredData.slice(startIndex, endIndex);

    // --- 4. RENDER TABLE AND PAGINATION ---
    // Render the table with ONLY the data for the current page
    renderTable(tableContainerId, config.headers, paginatedData);
    
    renderPagination('pagination-controls', filteredData.length, rowsPerPage, currentPage);
}

/**
 * Safely parses a response that might be a JSON string or an object.
 * @param {string | object} response The API response.
 * @returns {object}
 */
function safeParseJson(response) {
    return typeof response === 'string' ? JSON.parse(response) : response;
}

async function renderPlatformAdminDataSourceTypesPage() {
    
    try {
        
        // Place this inside renderPlatformAdminPage, replacing your old 'headers' object.
        tableConfig = {
                headers: [
                    { label: "Name", key: "Name", widthClass: "w-4/12" },
                    { label: "Description", key: "Description", className: "break-words", widthClass: "w-4/12" },
                    {
                        label: "Active",
                        key: "IsActive",
                        render: (value) => value == 1 ? 'Yes' : 'No'
                    }, {
                        label: "Date Modified",
                        key: "ModifiedDate",
                        render: (value) => formatDate(value)
                    }
                ]
            };
        
        
        // --- SEARCH EVENT LISTENER ---
        searchInput.addEventListener('input', () => {
            // When a new search is performed, always go back to page 1
            fetchAndRenderPage(1, searchInput.value);
        });
        
        // --- NEW PAGINATION EVENT LISTENER (EVENT DELEGATION) ---
        const paginationContainer = document.getElementById('pagination-controls');
        paginationContainer.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-page]');
            if (!button || button.disabled) {
                return;
            }
            const newPage = parseInt(button.dataset.page, 10);
            console.log('newPage')
            console.log(newPage)
            // Fetch the new page, preserving the current search term
            fetchAndRenderPage(newPage, searchInput.value);
        });

        paginationContainer.addEventListener('keydown', (event) => {
            // Only act if the user pressed Enter and the target is our input
            if (event.key === 'Enter' && event.target.id === 'page-input') {
                const inputElement = event.target;
                const newPage = parseInt(inputElement.value, 10);

                // Validate the input
                if (newPage >= 1 && newPage <= totalPages) {
                    fetchAndRenderPage(newPage, searchInput.value);
                } else {
                    // If invalid, show a message and reset the input to the current page
                    alert(`Please enter a page number between 1 and ${totalPages}.`);
                    inputElement.value = currentPage; 
                }
            }
        });

        const addDataSrcTypeBtn = document.querySelector('#addDataSrcTypeBtn');;
        if (addDataSrcTypeBtn) {
            addDataSrcTypeBtn.addEventListener('click', () => {
                AddDataSrcType();
            });
        }
        const saveButton = document.getElementById('modal-save-add-datasrctype-button');
        const handleSaveClick = async () => {
            // Get the modal instance at the time of clicking (not during page load)
            const modalInstance = bootstrap.Modal.getInstance(document.getElementById('addDataSrcTypeModal'));
            
            const form = document.getElementById('addDataSrcTypeForm');
            
            if (!form.checkValidity()) {
                form.classList.add('was-validated');
                console.log("Form is invalid. Aborting save.");
                return;
            }

            const payload = getDataSrcTypeFormData(form);
            console.log("Data gathered from form:", payload);
            
            saveButton.disabled = true;
            saveButton.innerHTML = `
                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                Saving...
            `;

            try {
                
                const response = await window.loomeApi.runApiRequest(API_ADD_METADATA, payload);
                console.log("RESPONSE: ", response)
                
                showToast('Data Source Type created successfully!');
                
                // This should now work!
                modalInstance.hide();
                
                // Optional: Refresh the table to show the new item
                await fetchAndRenderPage(tableConfig, 1, '');
                
            } catch (error) {
                console.error("API call failed:", error);
                showToast(`Error: ${error.message || 'Failed to save data.'}`, 'error');
            } finally {
                saveButton.disabled = false;
                saveButton.innerHTML = 'Save';
            }
        };

        // --- 6. Add the event listener ---
        // This tells the browser: "When a 'click' happens on 'saveButton', run the 'handleSaveClick' function."
        saveButton.addEventListener('click', handleSaveClick);

        // --- 3. Initial Page Load ---
        // Make the first call to fetch page 1 with no search term.
        console.log("Initial fetchAndRenderPage call: ", tableConfig)
        await fetchAndRenderPage(1, '');
            
        
    } catch (error) {
        console.error("Error setting up the page:", error);
    
        // Get the error message from the error object
        const errorMessage = error.message; 
        
        const container = document.getElementById(TABLE_CONTAINER_ID);
        
        // Display the specific error message in the UI
        container.innerHTML = `
            <div class="alert alert-danger" role="alert">
                <strong>An error occurred:</strong> ${errorMessage}
            </div>
        `;
    }

    
}

// --- AUTO-EXECUTE ONLY IN BROWSER ---
if (typeof window !== 'undefined' && typeof module === 'undefined') {
    renderPlatformAdminDataSourceTypesPage();
}

// --- EXPORT FOR TESTING (Node.js environment only) ---
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        safeParseJson,
        formatDate,
        getDataSrcTypeFormData,
        AddDataSrcType,
        renderPagination,
        renderTable,
        renderAccordionDetails,
        fetchAndRenderPage,
        updateTable,
        renderPlatformAdminDataSourceTypesPage
    };
}

// =============================================================================
// UNIT TESTS (Jest - only run in Node.js test environment)
// =============================================================================
if (typeof describe !== 'undefined') {

    // --- Suppress console output during tests for cleaner output ---
    let originalConsole;
    beforeAll(() => {
        originalConsole = {
            log: console.log,
            warn: console.warn,
            error: console.error
        };
        console.log = jest.fn();
        console.warn = jest.fn();
        console.error = jest.fn();
    });

    afterAll(() => {
        console.log = originalConsole.log;
        console.warn = originalConsole.warn;
        console.error = originalConsole.error;
    });

    // --- MOCK DATA based on API Response Structures ---
    const mockGetDataSourceTypesResponse = {
        CurrentPage: 1,
        PageCount: 2,
        PageSize: 5,
        RowCount: 8,
        FirstRowOnPage: 1,
        LastRowOnPage: 5,
        Results: [
            {
                DataSourceTypeID: 1,
                Name: "Database",
                Description: "Database connection type",
                IsActive: true,
                ModifiedDate: "2026-01-11T10:19:09.222Z"
            },
            {
                DataSourceTypeID: 2,
                Name: "REDCap API",
                Description: "REDCap API connection",
                IsActive: true,
                ModifiedDate: "2026-01-10T08:00:00.000Z"
            },
            {
                DataSourceTypeID: 3,
                Name: "Folder",
                Description: null,
                IsActive: false,
                ModifiedDate: null
            }
        ]
    };

    const mockAddMetaDataPayload = {
        Name: "New Type",
        Description: "A new data source type",
        IsActive: true
    };

    const mockUpdateMetaDataPayload = {
        Name: "Updated Type",
        Description: "Updated description",
        IsActive: false
    };

    // --- TEST SUITE: safeParseJson ---
    describe('safeParseJson', () => {
        test('should return the same object when input is already an object', () => {
            const input = { key: 'value', number: 42 };
            const result = safeParseJson(input);
            expect(result).toEqual(input);
            expect(result).toBe(input);
        });

        test('should parse a valid JSON string into an object', () => {
            const input = '{"key": "value", "number": 42}';
            const result = safeParseJson(input);
            expect(result).toEqual({ key: 'value', number: 42 });
        });

        test('should parse a JSON array string', () => {
            const input = '[1, 2, 3]';
            const result = safeParseJson(input);
            expect(result).toEqual([1, 2, 3]);
        });

        test('should throw an error for invalid JSON string', () => {
            const input = 'not valid json';
            expect(() => safeParseJson(input)).toThrow(SyntaxError);
        });

        test('should handle empty object string', () => {
            const result = safeParseJson('{}');
            expect(result).toEqual({});
        });

        test('should handle GetDataSourceTypes API response structure', () => {
            const jsonString = JSON.stringify(mockGetDataSourceTypesResponse);
            const result = safeParseJson(jsonString);
            expect(result.CurrentPage).toBe(1);
            expect(result.Results).toHaveLength(3);
            expect(result.Results[0].Name).toBe("Database");
        });
    });

    // --- TEST SUITE: formatDate ---
    describe('formatDate', () => {
        test('should format a valid ISO date string', () => {
            const result = formatDate("2026-01-11T10:19:09.222Z");
            expect(result).toBe("January 11, 2026");
        });

        test('should format a date without time component', () => {
            const result = formatDate("2025-12-25");
            expect(result).toBe("December 25, 2025");
        });

        test('should return "N/A" for null input', () => {
            const result = formatDate(null);
            expect(result).toBe('N/A');
        });

        test('should return "N/A" for undefined input', () => {
            const result = formatDate(undefined);
            expect(result).toBe('N/A');
        });

        test('should return "N/A" for empty string input', () => {
            const result = formatDate('');
            expect(result).toBe('N/A');
        });

        test('should return "N/A" for invalid date string', () => {
            const result = formatDate('not a date');
            expect(result).toBe('N/A');
        });

        test('should handle ModifiedDate from API response', () => {
            const apiItem = mockGetDataSourceTypesResponse.Results[0];
            const result = formatDate(apiItem.ModifiedDate);
            expect(result).toBe("January 11, 2026");
        });

        test('should handle null ModifiedDate from API response', () => {
            const apiItem = mockGetDataSourceTypesResponse.Results[2];
            const result = formatDate(apiItem.ModifiedDate);
            expect(result).toBe('N/A');
        });
    });

    // --- TEST SUITE: getDataSrcTypeFormData ---
    describe('getDataSrcTypeFormData', () => {
        test('should return null when form element is not provided', () => {
            const result = getDataSrcTypeFormData(null);
            expect(result).toBeNull();
        });

        test('should return null when form element is undefined', () => {
            const result = getDataSrcTypeFormData(undefined);
            expect(result).toBeNull();
        });

        test('should extract form data correctly', () => {
            // Create a mock form element
            const form = document.createElement('form');
            form.innerHTML = `
                <input id="dataSrcTypeName" value="Test Type">
                <textarea id="dataSrcTypeDescription">Test Description</textarea>
                <input type="checkbox" id="dataSrcTypeActive" checked>
            `;
            document.body.appendChild(form);

            const result = getDataSrcTypeFormData(form);

            expect(result).toEqual({
                name: "Test Type",
                description: "Test Description",
                isActive: true
            });

            document.body.removeChild(form);
        });

        test('should handle unchecked isActive checkbox', () => {
            const form = document.createElement('form');
            form.innerHTML = `
                <input id="dataSrcTypeName" value="Inactive Type">
                <textarea id="dataSrcTypeDescription">Description</textarea>
                <input type="checkbox" id="dataSrcTypeActive">
            `;
            document.body.appendChild(form);

            const result = getDataSrcTypeFormData(form);

            expect(result.isActive).toBe(false);

            document.body.removeChild(form);
        });

        test('should handle empty description', () => {
            const form = document.createElement('form');
            form.innerHTML = `
                <input id="dataSrcTypeName" value="No Description Type">
                <textarea id="dataSrcTypeDescription"></textarea>
                <input type="checkbox" id="dataSrcTypeActive" checked>
            `;
            document.body.appendChild(form);

            const result = getDataSrcTypeFormData(form);

            expect(result.description).toBe("");

            document.body.removeChild(form);
        });
    });

    // --- TEST SUITE: renderAccordionDetails ---
    describe('renderAccordionDetails', () => {
        test('should render accordion HTML with all fields', () => {
            const item = {
                DataSourceTypeID: 1,
                Name: "Database",
                Description: "Database connection",
                IsActive: true,
                ModifiedDate: "2026-01-11T10:00:00Z"
            };

            const result = renderAccordionDetails(item);

            expect(result).toContain('data-id="1"');
            expect(result).toContain('Database');
            expect(result).toContain('Database connection');
            expect(result).toContain('Yes');
            expect(result).toContain('January 11, 2026');
        });

        test('should handle null description', () => {
            const item = {
                DataSourceTypeID: 2,
                Name: "Test",
                Description: null,
                IsActive: false,
                ModifiedDate: "2026-01-10T00:00:00Z"
            };

            const result = renderAccordionDetails(item);

            expect(result).toContain('data-id="2"');
            expect(result).toContain('No'); // IsActive = false
        });

        test('should handle null ModifiedDate', () => {
            const item = {
                DataSourceTypeID: 3,
                Name: "No Date",
                Description: "Test",
                IsActive: true,
                ModifiedDate: null
            };

            const result = renderAccordionDetails(item);

            expect(result).toContain('N/A');
        });
    });

    // --- TEST SUITE: renderPagination ---
    describe('renderPagination', () => {
        beforeEach(() => {
            // Create pagination container
            const container = document.createElement('div');
            container.id = 'pagination-controls';
            document.body.appendChild(container);
        });

        afterEach(() => {
            const container = document.getElementById('pagination-controls');
            if (container) {
                document.body.removeChild(container);
            }
        });

        test('should not render pagination when totalPages <= 1', () => {
            renderPagination('pagination-controls', 5, 10, 1);
            
            const container = document.getElementById('pagination-controls');
            expect(container.innerHTML).toBe('');
        });

        test('should render pagination buttons for multiple pages', () => {
            renderPagination('pagination-controls', 25, 5, 1);
            
            const container = document.getElementById('pagination-controls');
            expect(container.innerHTML).toContain('Previous');
            expect(container.innerHTML).toContain('Next');
            expect(container.innerHTML).toContain('data-page="1"');
            expect(container.innerHTML).toContain('data-page="5"');
        });

        test('should disable Previous button on first page', () => {
            renderPagination('pagination-controls', 20, 5, 1);
            
            const container = document.getElementById('pagination-controls');
            const prevButton = container.querySelector('button[data-page="0"]');
            expect(prevButton.disabled).toBe(true);
        });

        test('should disable Next button on last page', () => {
            renderPagination('pagination-controls', 20, 5, 4);
            
            const container = document.getElementById('pagination-controls');
            const nextButton = container.querySelector('button[data-page="5"]');
            expect(nextButton.disabled).toBe(true);
        });

        test('should highlight current page', () => {
            renderPagination('pagination-controls', 15, 5, 2);
            
            const container = document.getElementById('pagination-controls');
            const currentPageButton = container.querySelector('button[data-page="2"]');
            expect(currentPageButton.className).toContain('bg-blue-600');
        });

        test('should handle missing container gracefully', () => {
            // Remove the container
            const container = document.getElementById('pagination-controls');
            document.body.removeChild(container);

            // Should not throw an error
            expect(() => renderPagination('non-existent', 20, 5, 1)).not.toThrow();
        });
    });

    // --- TEST SUITE: renderTable ---
    describe('renderTable', () => {
        beforeEach(() => {
            const container = document.createElement('div');
            container.id = 'test-table-container';
            document.body.appendChild(container);
        });

        afterEach(() => {
            const container = document.getElementById('test-table-container');
            if (container) {
                document.body.removeChild(container);
            }
        });

        test('should render table with headers and data', () => {
            const headers = [
                { label: "Name", key: "Name" },
                { label: "Active", key: "IsActive" }
            ];
            const data = [
                { Name: "Test1", IsActive: true },
                { Name: "Test2", IsActive: false }
            ];

            renderTable('test-table-container', headers, data);

            const container = document.getElementById('test-table-container');
            expect(container.querySelector('table')).not.toBeNull();
            expect(container.innerHTML).toContain('Name');
            expect(container.innerHTML).toContain('Test1');
            expect(container.innerHTML).toContain('Test2');
        });

        test('should show "No data found" for empty data array', () => {
            const headers = [
                { label: "Name", key: "Name" }
            ];

            renderTable('test-table-container', headers, []);

            const container = document.getElementById('test-table-container');
            expect(container.innerHTML).toContain('No data found');
        });

        test('should apply custom render function', () => {
            const headers = [
                { 
                    label: "Status", 
                    key: "IsActive",
                    render: (value) => value ? 'Active' : 'Inactive'
                }
            ];
            const data = [{ IsActive: true }];

            renderTable('test-table-container', headers, data);

            const container = document.getElementById('test-table-container');
            expect(container.innerHTML).toContain('Active');
        });

        test('should show N/A for null values', () => {
            const headers = [
                { label: "Description", key: "Description" }
            ];
            const data = [{ Description: null }];

            renderTable('test-table-container', headers, data);

            const container = document.getElementById('test-table-container');
            expect(container.innerHTML).toContain('N/A');
        });

        test('should handle missing container gracefully', () => {
            const container = document.getElementById('test-table-container');
            document.body.removeChild(container);

            expect(() => renderTable('non-existent', [], [])).not.toThrow();
        });
    });

    // --- TEST SUITE: fetchAndRenderPage ---
    describe('fetchAndRenderPage', () => {
        beforeEach(() => {
            // Setup DOM elements
            const tableContainer = document.createElement('div');
            tableContainer.id = 'requests-table-area';
            document.body.appendChild(tableContainer);

            const paginationContainer = document.createElement('div');
            paginationContainer.id = 'pagination-controls';
            document.body.appendChild(paginationContainer);

            const countElement = document.createElement('span');
            countElement.id = 'dataSourceTypesCount';
            document.body.appendChild(countElement);

            // Setup API mock
            window.loomeApi = {
                runApiRequest: jest.fn()
            };

            // Setup tableConfig (global state required by fetchAndRenderPage)
            tableConfig = {
                headers: [
                    { label: "Name", key: "Name", widthClass: "w-4/12" },
                    { label: "Description", key: "Description", className: "break-words", widthClass: "w-4/12" },
                    { label: "Active", key: "IsActive", render: (value) => value == 1 ? 'Yes' : 'No' },
                    { label: "Date Modified", key: "ModifiedDate", render: (value) => formatDate(value) }
                ]
            };
        });

        afterEach(() => {
            ['requests-table-area', 'pagination-controls', 'dataSourceTypesCount'].forEach(id => {
                const el = document.getElementById(id);
                if (el) document.body.removeChild(el);
            });
            delete window.loomeApi;
            tableConfig = {};
        });

        test('should fetch and render data successfully', async () => {
            window.loomeApi.runApiRequest.mockResolvedValue(mockGetDataSourceTypesResponse);

            await fetchAndRenderPage(1, '');

            // Verify API was called correctly
            expect(window.loomeApi.runApiRequest).toHaveBeenCalledWith(
                'GetDataSourceTypes',
                { page: 1, pageSize: 5, search: '' }
            );

            // Verify the API was called exactly once
            expect(window.loomeApi.runApiRequest).toHaveBeenCalledTimes(1);
        });

        test('should handle API error gracefully', async () => {
            window.loomeApi.runApiRequest.mockRejectedValue(new Error('Network error'));

            await fetchAndRenderPage(1, '');

            const container = document.getElementById('requests-table-area');
            expect(container.innerHTML).toContain('Error loading data');
        });

        test('should pass search term to API', async () => {
            window.loomeApi.runApiRequest.mockResolvedValue(mockGetDataSourceTypesResponse);

            await fetchAndRenderPage(1, 'database');

            expect(window.loomeApi.runApiRequest).toHaveBeenCalledWith(
                'GetDataSourceTypes',
                { page: 1, pageSize: 5, search: 'database' }
            );
        });

        test('should handle JSON string response', async () => {
            window.loomeApi.runApiRequest.mockResolvedValue(
                JSON.stringify(mockGetDataSourceTypesResponse)
            );

            await fetchAndRenderPage(1, '');

            const countEl = document.getElementById('dataSourceTypesCount');
            expect(countEl.textContent).toBe('8');
        });
    });

    // --- TEST SUITE: updateTable ---
    describe('updateTable', () => {
        beforeEach(() => {
            const tableContainer = document.createElement('div');
            tableContainer.id = 'test-update-container';
            document.body.appendChild(tableContainer);

            const paginationContainer = document.createElement('div');
            paginationContainer.id = 'pagination-controls';
            document.body.appendChild(paginationContainer);
        });

        afterEach(() => {
            ['test-update-container', 'pagination-controls'].forEach(id => {
                const el = document.getElementById(id);
                if (el) document.body.removeChild(el);
            });
        });

        test('should filter data by search term', () => {
            const config = {
                headers: [{ label: "Name", key: "Name" }]
            };
            const data = [
                { Name: "Database" },
                { Name: "Folder" },
                { Name: "API" }
            ];

            updateTable(config, data, 'test-update-container', 1, 10, 'folder');

            const container = document.getElementById('test-update-container');
            expect(container.innerHTML).toContain('Folder');
            expect(container.innerHTML).not.toContain('Database');
        });

        test('should paginate data correctly', () => {
            const config = {
                headers: [{ label: "Name", key: "Name" }]
            };
            const data = [
                { Name: "Item1" },
                { Name: "Item2" },
                { Name: "Item3" },
                { Name: "Item4" },
                { Name: "Item5" }
            ];

            updateTable(config, data, 'test-update-container', 2, 2, '');

            const container = document.getElementById('test-update-container');
            expect(container.innerHTML).toContain('Item3');
            expect(container.innerHTML).toContain('Item4');
            expect(container.innerHTML).not.toContain('Item1');
        });

        test('should handle case-insensitive search', () => {
            const config = {
                headers: [{ label: "Name", key: "Name" }]
            };
            const data = [
                { Name: "DATABASE" },
                { Name: "folder" }
            ];

            updateTable(config, data, 'test-update-container', 1, 10, 'DATABASE');

            const container = document.getElementById('test-update-container');
            expect(container.innerHTML).toContain('DATABASE');
        });
    });

} // End of test block
